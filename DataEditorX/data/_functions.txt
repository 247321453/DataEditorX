###############################################
# 脚本中用到的数据类型为以下几类：
# int:		整数类型
# bool:		布尔类型(true 或者 false)
# string:	字符串
# function:	函数
# Card:		卡片类
# Effect:	效果类
# Group:	卡片组类
# table:	表类型
# nil:		空类型，也表示空的变量
# any:		任意类型
# 为方便说明，采用类似C的函数表示方法说明
# []表示有默认值可省略的参数
# 只说明有意义的nil类型参数或返回值
#
# 注：关于过滤条件函数
#  过滤条件函数是指第一个参数是Card类型，并且返回值是boolean的函数。此函数用于在一些获取满足条件的卡片组的过滤函数中重复调用。过滤条件函数可以有不定的参数，第二个开始的参数从过滤函数的额外参数获得。举例：
# function sample_filter(c, atk, def)
# 	return c:GetAttack()>=atk and c:GetDefense()>=def
# end
# 此函数对于一张卡c，如果攻击力>=atk并且守备力>=def则返回true，否则返回false
# g=Duel.GetFieldGroup(0,LOCATION_HAND,0) --获取玩家1的手卡
# fg=g:Filter(sample_filter,nil,1000,500) --从g中筛选攻击力>=1000并且守备>=500的卡
# Group.Filter只需要3个参数，第4个参数开始为额外参数，额外的参数会传给sample_filter
#
# 注：关于指定位置
# 一些函数可以获取指定位置的卡，通过三个参数指定 int player, int s, int o
# s指对玩家player来说的己方的位置，o指对玩家player来说的对方的位置
# 比如Duel.GetFieldGroup(0,LOCATION_GRAVE,LOCATION_MZONE)
# 返回玩家0墓地和玩家1的怪兽区的所有卡
#
# 注：关于描述
# 脚本系统并不是直接使用字符串显示提示文字，而是由系统通过一个整数(int desc)查找相应的描述
# 对于desc<2048，系统在string.conf里面寻找，其中一些常用的数字(通常是提示选择的文字)在constant.lua中有记录
# 对于desc>10000，系统在卡片数据库中寻找描述，通常使用aux.Stringid()函数指定
#
#●void Duel.ReplaceAttacker(Card c)
#用c代替当前攻击的卡进行伤害阶段（此函数已不存在）
#●void Duel.ReplaceAttackTarget(Card c)
#(预留）（函数不存在）
#
#
#区域相关：
#自己场上从左往右，序号依次是0~4，额外怪兽区是5~6，0x7f 则表示全部主怪兽区+额外怪兽区
#获取的区域值 zone 是以2位底，区号为次幂的数，所以要获取正确的区号，需要做对数 math.log(zone,2)
#涉及到对方的区域，则需要把对方的值 左移16位
#
#换成二进制比较好直观理解：（空格是为了方便分辨是第几位）
#
#0x7f= 0111 1111
#把它从低位开始 倒序排，就是  1111 1110 ，前5个就代表自己的5个主要怪兽区，第6个就是左边的额外怪兽区，第7个是右边的额外怪兽区
#(0)= 1  = 0x1 	= 0000 0001
#(1)= 2  = 0x2 	= 0000 0010
#(2)= 4  = 0x4 	= 0000 0100
#(3)= 8  = 0x8 	= 0000 1000
#(4)= 16 = 0x10 = 0001 0000
#(5)= 32 = 0x20 = 0010 0000
#(6)= 64 = 0x40 = 0100 0000
#
##############################################

●void initial_effect(Card c)
载入卡片时调用
一般是注册初始卡片效果，以及设置苏生限制等等
========== bit ===========
bit库已删除，请用操作符操作，详见 utility.lua

========== Card ==========
●int[,int] Card.GetCode(Card c)
返回c的当前代号（可能因为效果改变）

●int Card.GetOriginalCode(Card c)
返回c的卡片记载的代号

●int,int Card.GetOriginalCodeRule(Card c)
返回c规则上的代号（这张卡规则上当作...使用）

●int[,int,...] Card.GetFusionCode(Card c)
返回c作为融合素材时的卡号（包括c原本的卡号）

●int[,int,...] Card.GetLinkCode(Card c)
返回c作为link素材的卡号（包括c原本的卡号）

●bool Card.IsFusionCode(Card c, int code[, ...])
检查c作为融合素材时能否当作卡号为code的卡，额外参数是其他code

●bool Card.IsLinkCode(Card c, int code[,...])
检查c作为link素材时能否当作卡号为code的卡，额外参数是其他code

●bool Card.IsSetCard(Card c, int setname)
检查c是否是卡名含有setname的卡

●bool Card.IsOriginalSetCard(Card c, int setname)
检查c是否是原本卡名含有setname的卡

●bool Card.IsPreviousSetCard(Card c, int setname)
检查c位置变化之前是否是名字含有setname的卡

●bool Card.IsFusionSetCard(Card c, int setname)
检查c作为融合素材时能否当作名字含有setname的卡

●bool Card.IsLinkSetCard(Card c, int setname)
检查c作为link素材时能否当作名字含有setname的卡

●int Card.GetType(Card c)
返回c的当前类型

●int Card.GetOriginalType(Card c)
返回c的卡片记载的类型

●int Card.GetFusionType(Card c)
返回c用作融合素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetSynchroType(Card c)
返回c用作同调素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetXyzType(Card c)
返回c用作同调素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetLinkType(Card c)
返回c用作link素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetLevel(Card c)
返回c的当前等级

●int Card.GetRank(Card c)
返回c的当前阶级

●int Card.GetLink(Card c)
返回c的连接标记数量

●int Card.GetSynchroLevel(Card c, Card sc)
返回c的对于同调怪兽sc的同调用等级
此函数除了某些特定卡如调节支援士，返回值与Card.GetLevel(c)相同

●int Card.GetRitualLevel(Card c, Card rc)
返回c的对于仪式怪兽rc仪式解放等级
此函数除了某些特定卡如仪式供物，返回值与Card.GetLevel(c)相同

●int Card.GetOriginalLevel(Card c)
返回c的卡片记载的等级

●int Card.GetOriginalRank(Card c)
返回c的卡片记载的阶级

●bool Card.IsXyzLevel(Card c, Card xyzc, int lv)
检查c对于超量怪兽xyzc的超量用等级是否是lv

●int Card.GetLeftScale(Card c)
返回c的左灵摆刻度

●int Card.GetOriginalLeftScale(Card c)
返回c的原本的左灵摆刻度

●int Card.GetRightScale(Card c)
返回c的右灵摆刻度

●int Card.GetOriginalRightScale(Card c)
返回c的原本的右灵摆刻度

●bool Card.IsLinkMarker(Card c, int dir)
检查c是否是连接标记为 dir 的卡
dir的值有：
LINK_MARKER_BOTTOM_LEFT		=0x001 -- ↙
LINK_MARKER_BOTTOM			=0x002 -- ↓
LINK_MARKER_BOTTOM_RIGHT	=0x004 -- ↘
LINK_MARKER_LEFT			=0x008 -- ←
LINK_MARKER_RIGHT			=0x020 -- →
LINK_MARKER_TOP_LEFT		=0x040 -- ↖
LINK_MARKER_TOP				=0x080 -- ↑
LINK_MARKER_TOP_RIGHT		=0x100 -- ↗

●Group Card.GetLinkedGroup(Card c)
返回c所连接区的卡片组

●int Card.GetLinkedGroupCount(Card c)
返回c所连接区的怪兽卡数量

●int Card.GetLinkedZone(Card c[, int player=c:GetControler()])
返回c的[以 player 来看的场上的]连接区域

●Group Card.GetMutualLinkedGroup(Card c)
返回和c互相连接状态的卡片组

●int Card.GetMutualLinkedGroupCount(Card c)
返回和c互相连接状态的卡片组的数量

●int Card.GetMutualLinkedZone(Card c[, int player=c:GetControler()])
返回[以 player 来看的]与卡片 c 互相连接的卡 所在的区域 

●bool Card.IsLinkState(Card c)
检查c是否是连接状态

●bool Card.IsExtraLinkState(Card c)
检查c是否是额外连接状态

●Group Card.GetColumnGroup(Card c[,int left=0, int right=0])
返回与c同一纵列的c以外的卡片组，后2个参数会计算卡片c左边 left 列 和右边 right 列的所有卡，
比如c在中间的格子，那么 c:GetColumnGroup(2,2) 就相当于获取了除场地魔法以外的 场上的所有卡

●int Card.GetColumnGroupCount(Card c[,int left=0, int right=0])
用法同上，只是返回的是卡片的数量

●int Card.GetColumnZone(Card c, int location[, int left, int right, int player])
返回[以 player 来看的] location 范围内与 c 同一纵列[包含左边 left 列和右边 right 列]的区域，
location 的值是 LOCATION_MZONE,LOCATION_SZONE,LOCATIOIN_ONFIELD 

●bool Card.IsAllColumn(Card c)
检查与c同一纵列的区域是否全都有卡

●int Card.GetAttribute(Card c)
返回c的当前属性
注：对某些多属性怪兽如光与暗之龙，此函数的返回值可能是几个属性的组合值

●int Card.GetOriginalAttribute(Card c)
返回c的卡片记载的属性

●int Card.GetFusionAttribute(Card c[, int player])
返回c[由player融合召唤时]用作融合素材时的属性

●int Card.GetLinkAttribute(Card c[, int player])
返回c[由player连接召唤时]用作连接素材时的属性

●int Card.GetRace(Card c)
返回c的当前种族
注：对某些多种族怪兽如动画效果的魔术猿，此函数的返回值可能是几个种族的组合值

●int Card.GetOriginalRace(Card c)
返回c的卡片记载的种族

●int Card.GetLinkRace(Card c[, int player])
返回c[由player连接召唤时]作为连接素材时的种族

●int Card.GetAttack(Card c)
返回c的当前攻击力

●int Card.GetBaseAttack(Card c)
返回c的原本攻击力

●int Card.GetTextAttack(Card c)
返回c的卡片记载的攻击力，返回值是负数表示是"?"

●int Card.GetDefense(Card c)
返回c的当前守备力

●int Card.GetBaseDefense(Card c)
返回c的原本守备力

●int Card.GetTextDefense(Card c)
返回c的卡片记载的守备力，返回值是负数表示是"?"

●int[,int] Card.GetPreviousCodeOnField(Card c)
返回c位置变化之前在场上的卡号

●int Card.GetPreviousTypeOnField(Card c)
返回c位置变化之前在场上的类型

●int Card.GetPreviousLevelOnField(Card c)
返回c位置变化之前在场上的等级

●int Card.GetPreviousRankOnField(Card c)
返回c位置变化之前在场上的阶级

●int Card.GetPreviousAttributeOnField(Card c)
返回c位置变化之前在场上的属性

●int Card.GetPreviousRaceOnField(Card c)
返回c位置变化之前在场上的种族

●int Card.GetPreviousAttackOnField(Card c)
返回c位置变化之前在场上的攻击力

●int Card.GetPreviousDefenseOnField(Card c)
返回c位置变化之前在场上的守备力

●int Card.GetOwner(Card c)
返回c的持有者

●int Card.GetControler(Card c)
返回c的当前控制者

●int Card.GetPreviousControler(Card c)
返回c的位置变化之前的控制者

●int Card.GetReason(Card c)
返回c的位置变化原因

●Card Card.GetReasonCard(Card c)
返回导致c的位置变化的卡
此函数仅在某卡被战斗破坏时，因为上级召唤被解放，或者成为特殊召唤使用的素材时有效

●int Card.GetReasonPlayer(Card c)
返回导致c的位置变化的玩家

●Effect Card.GetReasonEffect(Card c)
返回导致c的位置变化的效果

●int Card.GetPosition(Card c)
返回c当前的表示形式

●int Card.GetPreviousPosition(Card c)
返回c位置变化前的表示形式

●int Card.GetBattlePosition(Card c)
返回c在本次战斗发生之前的表示形式

●int Card.GetLocation(Card c)
返回c当前的所在位置

●int Card.GetPreviousLocation(Card c)
返回c位置变化前的所在的位置

●int Card.GetSequence(Card c)
返回c在当前位置的序号
在场上时，序号代表所在的格子，从左往右分别是0-4，场地魔法格的序号为5，左右灵摆区域为6-7
在其它地方时，序号表示的是第几张卡，最下面的卡的序号为0

●int Card.GetPreviousSequence(Card c)
返回c位置变化前的序号

●int Card.GetSummonType(Card c)
返回c的召唤/特殊召唤的方式

●int Card.GetSummonLocation(Card c)
返回c的召唤/特殊召唤的位置

●int Card.GetSummonPlayer(Card c)
返回召唤/特殊召唤 c 上场的玩家

●int Card.GetDestination(Card c)
返回c位置变化的目的地
此函数仅在处理位置转移代替效果时有效

●int Card.GetLeaveFieldDest(Card c)
返回c离场时因改变去向的效果（如大宇宙）的目的地

●int Card.GetTurnID(Card c)
返回c转移到当前位置的回合

●int Card.GetFieldID(Card c)
返回c转移到当前位置的时间标识
此数值唯一，越小表示c是越早出现在那个位置
卡片从里侧翻开也会改变此数值

●int Card.GetRealFieldID(Card c)
返回c转移到当前位置的真实的时间标识
卡片从里侧翻开不会改变此数值

●bool Card.IsCode(Card c, int code1[, int code2,...])
检查c的卡号是否是 code1[, 或者为 code2...]

●bool Card.IsType(Card c, int type)
检查c是否属于类型type

●bool Card.IsFusionType(Card c, int type)
检查c用作融合素材时是否属于类型type（与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsSynchroType(Card c, int type)
检查c用作同调素材时是否属于类型type（与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsXyzType(Card c, int type)
检查c用作超量素材时是否属于类型type（与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsLinkType(Card c, int type)
检查c用作连接素材时是否属于类型type（与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsLevel(Card c, int level1[, int level2,...])
检查c是否是等级 level1[, 或者为 level2...]

●bool Card.IsRank(Card c, int rank1[, int rank2,...])
检查c是否是阶级 rank1[, 或者为 rank2...]

●bool Card.IsLink(Card c, int link1[, int link2,...])
检查c的连接标记数量是否是 link1[, 或者为 link2...]

●bool Card.IsAttack(Card c, int atk1[, int atk2,...])
检查c的攻击力是否是 atk1[, 或者为 atk2...]，如果c不是怪兽卡，或者不在 LOCATION_MZONE 则都返回false

●bool Card.IsDefense(Card c, int def[, int atk2,...])
检查c的守备力是否是 def1[, 或者为 def2...]，如果c不是怪兽卡，或者不在 LOCATION_MZONE 则都返回false

●bool Card.IsRace(Card c, int race)
检查c是否属于种族race

●bool Card.IsLinkRace(Card c, int race[, int player])
检查c[由player连接召唤时]用作连接素材时是否属于种族race

●bool Card.IsAttribute(Card c, int attribute)
检查c是否属于属性attribute

●bool Card.IsFusionAttribute(Card c, int attribute[, int player])
检查c[由player融合召唤时]用作融合素材是否属于属性attribute

●bool Card.IsLinkAttribute(Card c, int attribute[, int player])
检查c[由player连接召唤时]用作连接素材是否属于属性attribute

●bool Card.IsReason(Card c, int reason)
检查c是否包含原因reason

●bool Card.IsSummonType(Card c, int sumtype)
检查c的召唤类型是否是sumtype

●bool Card.IsStatus(Card c, int status)
检查c是否包含某个状态码

●bool Card.IsNotTuner(Card c)
检查c是否可以当成非调整来使用

●void Card.SetStatus(Card c, int state, bool enable)
给c设置或者取消状态码
除非妳清楚的了解每个状态码的含意，否则不要轻易使用此函数

●bool Card.IsDualState(Card c)
检查c属否处于再召唤状态

●void Card.EnableDualState(Card c)
把c设置成再召唤状态

●void Card.SetTurnCounter(Card c, int counter)
设置c的回合计数器（光之护封剑等）

●int Card.GetTurnCounter(Card c)
返回c的回合计数器

●void Card.SetMaterial(Card c, Group g)
把g中的所有卡作为c的素材（上级召唤，特殊召唤）

●Group Card.GetMaterial(Card c)
返回c出场使用的素材

●int Card.GetMaterialCount(Card c)
返回c出场使用的素材数量

●Group Card.GetEquipGroup(Card c)
返回c当前装备着的卡片组

●int Card.GetEquipCount(Card c)
返回c当前装备着的卡片数量

●Card Card.GetEquipTarget(Card c)
返回c当前的装备对象

●Card Card.GetPreviousEquipTarget(Card c)
返回c之前的装备对象

●bool Card.CheckEquipTarget(Card c1, Card c2)
检查c2是否是c1的正确的装备对象
##由EFFECT_EQUIP_LIMIT效果或同盟状态确定

●int Card.GetUnionCount(Card c)
返回c当前装备的同盟卡数量

●Group Card.GetOverlayGroup(Card c)
返回c当前叠放着的卡片组

●int Card.GetOverlayCount(Card c)
返回c当前叠放着的卡片数量

●Card Card.GetOverlayTarget(Card c)
返回以c为超量素材的卡

●bool Card.CheckRemoveOverlayCard(Card c, int player, int count, int reason)
检查玩家player能否以reason为原因，至少移除c叠放的count张卡

●int Card.RemoveOverlayCard(Card c, int player, int min, int max, int reason)
以reason为原因，让玩家player移除c叠放的min-max张卡，返回值表示是否成功

●Group Card.GetAttackedGroup(Card c)
返回c本回合攻击过的卡片组

●int Card.GetAttackedGroupCount(Card c)
返回c本回合攻击过的卡片数量

●int Card.GetAttackedCount(Card c)
返回c本回合攻击过的次数
注：如果此值与上一个函数的返回值不同，那么说明此卡本回合进行过直接攻击

●Group Card.GetBattledGroup(Card c)
返回与c本回合进行过战斗的卡片组
进行过战斗指发生过伤害的计算，用于剑斗兽等卡的判定

●int Card.GetBattledGroupCount(Card c)
返回与c本回合进行过战斗的的卡片数量

●int Card.GetAttackAnnouncedCount(Card c)
返回c本回合攻击宣言的次数
注：攻击被无效不会被计入攻击过的次数，但是会计入攻击宣言的次数

●bool Card.IsDirectAttacked(Card c)
检查c是否直接攻击过

●void Card.SetCardTarget(Card c1, Card c2)
把c2作为c1的永续对象
c1和c2的联系会在c1或c2任意一卡离场或变成里侧表示时reset

●Group Card.GetCardTarget(Card c)
返回c当前所有的永续对象

●Card Card.GetFirstCardTarget(Card c)
返回c当前第一个永续对象，没有则返回 nil

●int Card.GetCardTargetCount(Card c)
返回c当前的永续对象的数量

●bool Card.IsHasCardTarget(Card c1, Card c2)
检查c2是否取c1为永续对象

●void Card.CancelCardTarget(Card c1, Card c2)
取消c2为c1的永续对象

●Group Card.GetOwnerTarget(Card c)
返回取c作为永续对象的所有卡

●int Card.GetOwnerTargetCount(Card c)
返回取c作为永续对象的卡的数量

●Effect,... Card.GetActivateEffect(Card c)
返回c的“卡片发动”的效果，即类型为EFFECT_TYPE_ACTIVATE的效果
仅对魔法和陷阱有效

●Effect[,Group,int,int,Effect,int,int] Card.CheckActivateEffect(Card c, bool neglect_con, bool neglect_cost, bool copy_info)
返回c的可以发动时机正确的“卡的发动”的效果，neglect_con=true则无视发动条件，neglect_cost=true则无视发动cost
copy_info=false或者自由时点的效果则只返回这个效果 e
否则还返回这个效果的触发时点的信息 e,eg,ep,ev,re,r,rp

●void|Effect[,function,int,int,int] Card.GetTunerLimit(Card c)
如果卡片 c 受到同调素材限制效果 EFFECT_TUNER_MATERIAL_LIMIT 影响，则返回 Effect e,function target,int value,int min,int max ;否则返回nil

●void|Effect[,function,int,int] Card.GetHandSynchro(Card c)
如果卡片 c 受到手卡同调效果 EFFECT_HAND_SYNCHRO 影响，则返回 Effect e,function target,int min,int max ;否则返回nil

●int Card.RegisterEffect(Card c, Effect e[, bool forced=false])
把效果e注册给c，返回效果的全局id，并设置e的Handler为c
默认情况下注册时如果c带有免疫e的效果那么注册会失败
如果forced为true则不会检查c对e的免疫效果

●... Card.IsHasEffect(Card c, int code)
检查c是否受到效果种类是code的效果的影响
没有则返回nil
有则返回那些效果

●void Card.ResetEffect(Card c, int reset_code, int reset_type)
以重置类型为reset_type、重置种类为reset_code手动重置c受到的效果的影响
reset_type只能是以下类型，对应的重置种类为
RESET_EVENT       发生事件重置        reset_code为事件
RESET_PHASE       阶段结束重置        reset_code为阶段
RESET_CODE        重置指定code的效果  reset_code为效果的种类code，只能重置EFFECT_TYPE_SINGLE的永续型效果
RESET_COPY        重置复制的效果      reset_code为copy_id
RESET_CARD        重置卡片的效果      reset_code为效果owner的卡号

●int Card.GetEffectCount(Card c, int code)
返回c受到影响的种类是code的效果的数量

●Effect Card.RegisterFlagEffect(Card c, int code, int reset_flag, int property, int reset_count[, int label, int desc])
为c注册一个标识用效果
注：注册给卡的标识用效果不会用于系统，
即使code与内置效果code重合也不会影响，
并且类型总是EFFECT_TYPE_SINGLE，reset方法，property和一般的效果相同，
并且不会无效化，不受卡的免疫效果影响

●int Card.GetFlagEffect(Card c, int code)
返回c的种类是code的标识效果的数量

●void Card.ResetFlagEffect(Card c, int code)
手动清除c的种类是code的标识效果

●bool Card.SetFlagEffectLabel(Card c, int code, int label)
返回c是否存在种类为code的标识效果，并设置其Label属性为label

●int[,...] Card.GetFlagEffectLabel(Card c, int code)
返回c的种类为code的标识效果的Label(数量可能不止一个)，没有此效果则返回nil

●void Card.CreateRelation(Card c1, Card c2, int reset_flag)
为c1建立与c2的联系，此联系仅会由于c1发生RESET_EVENT的事件reset

●void Card.ReleaseRelation(Card c1, Card c2)
手动释放c1对于c2的联系

●void Card.CreateEffectRelation(Card c, Effect e)
为卡片c和效果e建立联系

●void Card.ReleaseEffectRelation(Card c,Effect e)
手动释放c与效果e的联系

●void Card.ClearEffectRelation(Card c)
清空c所有联系的效果

●bool Card.IsRelateToEffect(Card c, Effect e)
检查c是否和效果e有联系
注：每次发动进入连锁的效果时，发动效果的卡，以及发动效果时指定的对象
（用Duel.SetTargetCard或者Duel.SelectTarget指定的，包括取对象和不取对象）
会自动与那个效果建立联系，一旦离场，联系会重置

●bool Card.IsRelateToChain(Card c, int chainc)
检查c是否和连锁chainc有联系
注：每次发动进入连锁的效果时，发动效果的卡，以及发动效果时指定的对象
（用Duel.SetTargetCard或者Duel.SelectTarget指定的，包括取对象和不取对象）
会自动与那个效果建立联系，一旦离场，联系会重置

●bool Card.IsRelateToCard(Card c1, Card c2)
检查c1是否和c2有联系

●bool Card.IsRelateToBattle(Card c)
检查c是否和本次战斗关联
注：此效果通常用于伤害计算后伤害阶段结束前，用于检查战斗的卡是否离场过

●int Card.CopyEffect(Card c, int code, int reset_flag[, int reset_count=1])
为c添加卡号是code的卡的可复制的效果，并且添加额外的reset条件
返回值是表示复制效果的代号id

●int Card.ReplaceEffect(Card c, int code, int reset_flag[, int reset_count=1])
把c的效果替换为卡号是code的卡的效果，并且添加额外的reset条件
返回值是表示替换效果的代号id

●void Card.EnableUnsummonable(Card c)
将c设置为不可通常召唤的怪兽
##实际上是个不可复制、不会被无效的EFFECT_UNSUMMONABLE_CARD效果

●void Card.EnableReviveLimit(Card c)
为c添加苏生限制
##实际上是不可复制、不会被无效的EFFECT_UNSUMMONABLE_CARD和EFFECT_REVIVE_LIMIT效果

●void Card.CompleteProcedure(Card c)
使c完成正规的召唤手续
##此函数也可通过 c:SetStatus(STATUS_PROC_COMPLETE,true)实现

●bool Card.IsDisabled(Card c)
检查c是否处于无效状态

●bool Card.IsDestructable(Card c[, Effect e])
检查c是否是可被[效果 e]破坏的

●bool Card.IsSummonableCard(Card c)
检查c是否是可通常召唤的卡

●bool Card.IsFusionSummonableCard(Card c[, int sum_type])
检查c是否是可[用 sum_type 方式]融合召唤的卡

●bool Card.IsSpecialSummonable(Card c[, int sum_type])
检查是否可以对c[用 sum_type 方式]进行特殊召唤手续

●bool Card.IsSynchroSummonable(Card c ,Card tuner|nil[, Group mg])
检查是否可以以tuner作为调整，场上的卡[或mg]为同调素材对c进行同调召唤手续
如果tuner是nil，此函数与Card.IsSpecialSummonable作用相同

●bool Card.IsXyzSummonable(Card c, Group mg|nil[, min=0, max=0])
检查是否可以在场上的卡[或mg][中选出 min-max 个超量素材]对c进行超量召唤手续
如果mg为nil，此函数与 c:IsSpecialSummonable(SUMMON_TYPE_XYZ)作用相同

●bool Card.IsSummonable(Card c, bool ignore_count, Effect e|nil[, int min=0, int zone=0x1f])
检查c是否可以进行通常召唤（不包含通常召唤的set)，ignore_count=true则不检查召唤次数限制
e~=nil则检查c是否可以以效果e进行通常召唤，min表示至少需要的祭品数（用于区分妥协召唤与上级召唤）,zone 表示必须要召唤到的区域

●bool Card.IsMSetable(Card, bool ignore_count, Effect e|nil[, int min=0, int zone=0x1f])
检查c是否可进行通常召唤的set，ignore_count=true则不检查召唤次数限制
e~=nil则检查c是否可以以效果e进行通常召唤的set，min表示至少需要的祭品数（用于区分妥协召唤set与上级召唤set）,zone 表示必须要放置到的区域

●bool Card.IsSSetable(Card c[, bool ignore_field=false])
检查c是否可以set到魔法陷阱区，ignore_field=true则无视魔陷区格子是否能使用的限制

●bool Card.IsCanBeSpecialSummoned(Card c, Effect e, int sumtype, int sumplayer, bool nocheck, bool nolimit[, int sumpos=POS_FACEUP, int toplayer=sumplayer, int zone=0xff])
检查c是否可以被玩家sumplayer用效果e[以sumtype方式和sumpos表示形式]特殊召唤[到玩家 toplayer 的区域zone]
如果nocheck是true则不检查c的召唤条件，如果nolimit是true则不检查c的苏生限制

●bool Card.IsAbleToHand(Card c)
检查c是否可以送去手牌
注：仅当卡片或者玩家受到“不能加入手牌”的效果的影响时（如雷王）此函数才返回false
##以下几个函数类似

●bool Card.IsAbleToDeck(Card c)
检查c是否可以送去卡组

●bool Card.IsAbleToExtra(Card c)
检查c是否可以送去额外卡组
对于非融合、同调等额外怪兽或者非灵摆怪兽此函数均返回false

●bool Card.IsAbleToGrave(Card c)
检查c是否可以送去墓地

●bool Card.IsAbleToRemove(Card c[, int player])
检查c是否可以被玩家player除外

●bool Card.IsAbleToHandAsCost(Card c)
检查c是否可以作为cost送去手牌
注：此函数会在Card.IsAbleToHand的基础上追加检测c的实际目的地
当c送往手牌会被送去其它地方时（如缩退回路适用中，或者c是融合、同调 等额外怪兽的一种），此函数返回false
##以下几个函数类似

●bool Card.IsAbleToDeckAsCost(Card c)
检查c是否可以作为cost送去卡组

●bool Card.IsAbleToExtraAsCost(Card c)
检查c是否可以作为cost送去额外卡组，主卡组的灵摆卡会返回false

●bool Card.IsAbleToDeckOrExtraAsCost(Card c)
检查c是否可以作为cost送去卡组或额外卡组（用于新宇侠、剑斗兽融合怪兽的召唤手续检测）等价于 (c:IsAbleToDeckAsCost() or c:IsAbleToExtraAsCost())

●bool Card.IsAbleToGraveAsCost(Card c)
检查c是否可以作为cost送去墓地

●bool Card.IsAbleToRemoveAsCost(Card c)
检查c是否可以作为cost除外

●bool Card.IsAbleToDecreaseAttackAsCost(Card c[, int atk])
检查c是否可以作为cost降低[atk 数值]攻击力
若c不是怪兽或者不在怪兽区，或是里侧表示，或受到 EFFECT_SET_ATTACK_FINAL(邪神 恐惧根源等) or EFFECT_REVERSE_UPDATE(天邪鬼的诅咒)效果影响，或是攻击力小于atk，则返回false

●bool Card.IsAbleToDecreaseDefenseAsCost(Card c[, int def])
检查c是否可以作为cost降低[def 数值]守备力
若c不是怪兽或者不在怪兽区，或是里侧表示，或受到 EFFECT_SET_DEFENSE_FINAL(邪神 恐惧根源等) or EFFECT_REVERSE_UPDATE(天邪鬼的诅咒)效果影响，或是守备力小于def，则返回false

●bool Card.IsReleasable(Card c)
检查c是否可以被解放（非上级召唤用）

●bool Card.IsReleasableByEffect(Card c)
检查c是否可以被效果解放

●bool Card.IsDiscardable(Card[, int reason=REASON_COST])
检查c是否可以以reason原因丢弃
注：此函数仅用于检测，
以REASON_DISCARD作为原因把一张手卡送墓并不会导致那张卡不能丢弃

●bool Card.IsAttackable(Card c)
检查c是否可以攻击

●bool Card.IsChainAttackable(Card c[, int ac = 2, bool monsteronly = false])
检查c是否可以连续攻击，c的攻击宣言次数>=ac则返回false
monsteronly = true 则表示只能对怪兽攻击
注：当c因为闪光之双剑等效果进行过多次攻击之后此函数返回false

●bool Card.IsFaceup(Card c)
检查c是否是表侧表示

●bool Card.IsAttackPos(Card c)
检查c是否是攻击表示

●bool Card.IsFacedown(Card c)
检查c是否是里侧表示

●bool Card.IsDefensePos(Card c)
检查c是否是守备表示

●bool Card.IsPosition(Card c, int pos)
检查c是否是表示形式pos

●bool Card.IsPreviousPosition(Card c, int pos)
检查c位置变化之前是否是表示形式pos

●bool Card.IsControler(Card c, int controler)
检查c的当前控制着是否是controler

●bool Card.IsOnField(Card c)
检查c是否在场
注：当怪兽召唤，反转召唤，特殊召唤时召唤成功之前，此函数返回false

●bool Card.IsLocation(Card c, int location)
检查c当前位置是否是location
注：当怪兽召唤，反转召唤，特殊召唤时召唤成功之前，
并且location=LOCATION_MZONE时，此函数返回false

●bool Card.IsPreviousLocation(Card c, int location)
检查c之前的位置是否是location

●bool Card.IsLevelBelow(Card c, int level)
检查c是否是等级level以下（至少为1）

●bool Card.IsLevelAbove(Card c, int level)
检查c是否是等级level以上

●bool Card.IsRankBelow(Card c, int rank)
检查c是否是阶级rank以下（至少为1）

●bool Card.IsRankAbove(Card c, int rank)
检查c是否是阶级rank以上

●bool Card.IsLinkBelow(Card c, int link)
检查c是否连接标记数量是link以下（至少为1）

●bool Card.IsLinkAbove(Card c, int link)
检查c是否连接标记数量是link以上

●bool Card.IsAttackBelow(Card c, int atk)
检查c是否是攻击力atk以下（至少为0）

●bool Card.IsAttackAbove(Card c, int atk)
检查c是否是攻击力atk以上

●bool Card.IsDefenseBelow(Card c, int def)
检查c是否是守备力def以下（至少为0）

●bool Card.IsDefenseAbove(Card c, int def)
检查c是否是守备力def以上

●bool Card.IsPublic(Card c)
检查c是否处于公开状态

●bool Card.IsForbidden(Card c)
检查c是否处于被宣言禁止状态

●bool Card.IsAbleToChangeControler(Card c)
检查c是否可以改变控制权
注：仅当卡收到了“不能改变控制权”的效果的影响时，此函数返回false

●bool Card.IsControlerCanBeChanged(Card c[, bool ignore_mzone=false, int zone=0xff])
检查c的控制权是否可以改变。 ignore_mzone=true 会忽视转移控制权后的玩家场上是否有空格位， zone 表示必须要使用的位置

●bool Card.AddCounter(Card c, int countertype, int count[, int singly=false])
为c放置count个countertype类型的指示物，singly为true表示逐个添加至上限为止

●void Card.RemoveCounter(Card c, int player, int countertype, int count, int reason)
让玩家player以原因reason移除c上的count个countertype类型的指示物， countertype=0 则清除c的所有指示物

●int Card.GetCounter(Card c, int countertype)
返回c上的countertype类型的指示物的数量， countertype=0 则返回c上所有类型的指示物数量之和

●void Card.EnableCounterPermit(Card c, int countertype[, int location])
允许c[在位置location]放置那个需要“可以放置”才能放置的指示物countertype
location的默认值与c的种类有关，灵摆怪兽需要指定能否在怪兽区域或灵摆区域放置指示物

●void Card.SetCounterLimit(Card c, int countertype, int count)
设定c放置countertype类型指示物的上限

●bool Card.IsCanChangePosition(Card c)
检查c是否可以用效果改变表示形式

●bool Card.IsCanTurnSet(Card c)
检查c是否可以转成里侧表示

●bool Card.IsCanAddCounter(Card c, int countertype, int count[, int singly=false, int location])
检查c是否可以[逐个(singly=true)在 location 区域]放置count个countertype类型的指示物

●bool Card.IsCanRemoveCounter(Card c, int player, int countertype, int count, int reason)
检查玩家player是否可以以原因reason移除c上的count个countertype类型的指示物

●bool Card.IsCanBeFusionMaterial(Card c[, Card fc])
检查c是否可以成为[融合怪兽fc的]融合素材

●bool Card.IsCanBeSynchroMaterial(Card c[, Card sc, Card tuner])
检查c是否可以成为[以 tuner 为调整的同调怪兽sc的]同调素材

●bool Card.IsCanBeRitualMaterial(Card c, Card sc|nil)
检查c是否可以作为[仪式怪兽sc的]仪式素材,没有指定sc的场合，必须填nil

●bool Card.IsCanBeXyzMaterial(Card c, Card sc|nil)
检查c是否可以成为[超量怪兽sc的]超量素材,没有指定sc的场合，必须填nil

●bool Card.IsCanBeLinkMaterial(Card c, Card sc|nil)
检查c是否可以成为[连接怪兽sc的]连接素材,没有指定sc的场合，必须填nil

●bool Card.CheckFusionMaterial(Card c[, Group g|nil, Card gc|nil, int chkf=PLAYER_NONE])
检查场上[或g]是否包含了c需要[必须包含gc在内]的一组融合素材
##根据c的种类为EFFECT_FUSION_MATERIAL的效果的Condition函数检查

●bool Card.CheckFusionSubstitute(Card c, Card fc)
检查c能否代替融合怪兽fc的记述卡名的素材

●bool Card.IsImmuneToEffect(Card c, Effect e)
检查c是否免疫效果e（即不受效果e的影响）

●bool Card.IsCanBeEffectTarget(Card c[, Effect e])
检查c是否可以成为效果[e的]对象

●bool Card.IsCanBeBattleTarget(Card c1, Card c2)
检查c1是否可以成为c2的攻击目标

●void Card.AddMonsterAttribute(Card c, int type[, int attribute, int race, int level, int atk, int def])
为魔陷卡c添加怪兽数值,type 为怪兽类型，不能是没有等级的怪兽
注：在数据库中有记录的数值视为原本数值

●void Card.AddMonsterAttributeComplete(Card c)
为卡c添加数值完毕，需要和Card.AddMonsterAttribute 配套使用

●void Card.CancelToGrave(Card c[, bool cancel=true])
取消送墓确定状态，cancel=false则重新设置送墓确定状态
注：送墓确定状态指的是在场上发动的不留场的魔法和陷阱后，这些卡片的状态
送墓确定状态中的卡无法返回手牌和卡组，并且连锁结束时送去墓地
此函数的作用是取消此状态使其留场，用于光之护封剑和废铁稻草人等卡

●int,int Card.GetTributeRequirement(Card c)
返回通常召唤c所需要的祭品的最小和最大数量

●Card Card.GetBattleTarget(Card c)
返回与c进行战斗的卡，没有则返回nil

●Group,bool Card.GetAttackableTarget(Card c)
返回c可攻击的卡片组以及能否直接攻击

●void Card.SetHint(Card c, int type, int value)
为c设置类型为type的卡片提示信息
type只能为以下值，对应的value类型为
CHINT_TURN              回合数
CHINT_CARD              卡片id
CHINT_RACE              种族
CHINT_ATTRIBUTE         属性
CHINT_NUMBER            数字
CHINT_DESC              描述

●void Card.ReverseInDeck(Card c)
设置c在卡组中正面表示（POS_FACEUP_DEFENSE）

●void Card.SetUniqueOnField(Card c, int s, int o, function|int unique_code[, int unique_location=LOCATIOIN_ONFIELD])
设置c以unique_code只能在场上[或怪兽区域或魔陷区域，由unique_location决定]只能存在1张,function 的返回值类型必须是int
s不为0会检查自己场上的唯一性，o不为0则检查对方场上的唯一性

●bool Card.CheckUniqueOnField(Card c,int check_player[, int check_location=LOCATION_ONFIELD, Card icard|nil])
检查c在check_player场上的唯一性

●void Card.ResetNegateEffect(Card c[, int code1,...])
重置c受到的卡号为code1[, code2...]的卡片的效果的影响

●void Card.AssumeProperty(Card c,int assume_type, int assume_value)
把c的assume_type的数值当作assume_value使用（基因组斗士）
assume_type为以下类型
ASSUME_CODE         卡号
ASSUME_TYPE         类型
ASSUME_LEVEL        等级
ASSUME_RANK         阶级
ASSUME_ATTRIBUTE    属性
ASSUME_RACE         种族
ASSUME_ATTACK       攻击力
ASSUME_DEFENSE      守备力

●void Card.SetSPSummonOnce(Card c, int spsummon_code)
设置c一回合只能进行1次特殊召唤（灵兽，波动龙）
相同的spsummon_code共用1个次数

●bool Card.IsRitualType(Card c)
返回c的仪式召唤的种类。

●bool Card.SetEntityCode(Card c, int code[, bool no_alias=false])
把c的卡图，卡名，信息全部改成卡号为code的卡的信息，但是不改变效果。常用于卡片变身类效果。返回是否成功。
no_alias=true会把变身后c的同名卡信息去除。用于双面卡的处理。

●void Card.SetCardData(Card c, int type, int value)
把c的type的信息在本次决斗中永久性更改为value，如同更改卡片数据库一般。
type可以是以下之一：
CARDDATA_CODE			1
CARDDATA_ALIAS			2
CARDDATA_SETCODE		3
CARDDATA_TYPE			4
CARDDATA_LEVEL			5
CARDDATA_ATTRIBUTE		6
CARDDATA_RACE			7
CARDDATA_ATTACK			8
CARDDATA_DEFENSE		9
CARDDATA_LSCALE			10
CARDDATA_RSCALE			11
CARDDATA_LINK_MARKER	12

●int Card.GetLinkMarker(Card c)
返回c的连接标记。

●int Card.GetOriginalLinkMarker(Card c)
返回c的原本连接标记。

●bool Card.IsXyzSummonableByRose(Card c, Card c1, Card c2)
返回c是否可以用c1和c2这2张卡为素材超量召唤。超量召唤时，c1的等级当作和c2相同。

●int Card.GetRemovedOverlayCount(Card c)
返回c本回合被取除的超量素材数量。

========== Effect ==========
●Effect Effect.CreateEffect(Card c)
新建一个空效果
并且效果的Owner为c

●Effect Effect.GlobalEffect()
新建一个全局效果

●Effect Effect.Clone(Effect e)
新建一个效果e的副本

●void Effect.Reset(Effect e)
把效果e重置，重置之后不可以再使用此效果

●int Effect.GetFieldID(Effect e)
获取效果e的id

●void Effect.SetDescription(Effect e, int desc)
为效果e设置效果描述

●void Effect.SetCode(Effect e, int code)
为效果e设置Code属性

●void Effect.SetRange(Effect e, int range)
为效果e设置Range属性，即e的生效位置

●void Effect.SetTargetRange(Effect e, int s_range, int o_range)
为效果e设置Target Range属性
	s_range指影响的我方区域
	o_range值影响的对方区域
	如果property属性中指定了EFFECT_FLAG_ABSOLUTE_RANGE标志，
		那么s_range指玩家1受到影响的区域，o_range指玩家2受到影响的区域
	如果这是一个召唤(覆盖)/限制召唤(覆盖)/特殊召唤手续
	(EFFECT_SUMMON_PROC/EFFECT_LIMIT_SUMMON_PROC/EFFECT_SPSUMMON_PROC等)的效果，
		并且property指定了EFFECT_FLAG_SPSUM_PARAM标志，
		那么s_range表示特殊召唤到的哪个玩家的场地，
	o_range表示可选择的表示形式

●void Effect.SetAbsoluteRange(Effect e, int playerid, int s_range, int o_range)
设置target range属性并设置 EFFECT_FLAG_ABSOLUTE_TARGET 标志
	playerid != 0 s_range和o_range反转

●void Effect.SetCountLimit(Effect e, int count=1[, int code=0])
设置一回合可以发动的次数count（仅触发型效果有效），相同的code(不等于0或1时)共用1个次数
code包含以下数值具有特殊的性质
EFFECT_COUNT_CODE_OATH          誓约使用次数
EFFECT_COUNT_CODE_DUEL          决斗中使用次数
EFFECT_COUNT_CODE_SINGLE        同一张卡多个效果公共使用次数（不限制同名卡）

●void Effect.SetReset(Effect e, int reset_flag[, int reset_count=1])
设置reset参数

●void Effect.SetType(Effect e, int type)
为效果e设置Type属性

●void Effect.SetProperty(Effect e, int prop1[, int prop2])
设置Property属性

●void Effect.SetLabel(Effect e, int label)
设置Label属性

●void Effect.SetLabelObject(Effect e, Card|Group|Effect labelobject)
设置LabelObject属性

●void Effect.SetCategory(Effect e, int cate)
设置Category属性

●void Effect.SetHintTiming(Effect e, int s_time[, int o_time=s_time])
设置提示时点，第二个和第三个参数分别表示 自己 和对方的回合

●void Effect.SetCondition(Effect e, function con_func)
设置Condition属性

●void Effect.SetCost(Effect e, function cost_func)
设置Cost属性

●void Effect.SetTarget(Effect e, function targ_func)
设置Target属性

●void Effect.SetValue(Effect e, function|int|bool val)
设置Value属性

●void Effect.SetOperation(Effect e, nil|function op_func)
设置Operation属性

●void Effect.SetOwnerPlayer(Effect e[, int player=0])
设置OwnerPlayer属性为player

●int Effect.GetDescription(Effect e)
返回效果描述，没有则返回nil，下同（到 GetCategory ）

●int Effect.GetCode(Effect e)
返回code属性

●int Effect.GetType(Effect e)
返回Type属性

●int,int Effect.GetProperty(Effect e)
返回Property属性

●int Effect.GetLabel(Effect e)
返回Label属性

●Card|Group|Effect Effect.GetLabelObject(Effect e)
返回LabelObject属性

●int Effect.GetCategory(Effect e)
返回Category属性

●Card Effect.GetOwner(Effect e)
返回Owner属性

●Card Effect.GetHandler(Effect e)
返回效果在哪一张卡上生效(通常是用Card.RegisterEffect注册该效果的卡)

●function Effect.GetCondition(Effect e)
返回condition属性

●function Effect.GetTarget(Effect e)
返回target属性

●function Effect.GetCost(Effect e)
返回cost属性

●function|int Effect.GetValue(Effect e)
返回value属性

●function Effect.GetOperation(Effect e)
返回operation属性

●int Effect.GetActiveType(Effect e)
返回e的效果类型（怪兽·魔法·陷阱）
与发动该效果的卡的类型不一定相同，比如灵摆效果视为魔法卡的效果

●bool Effect.IsActiveType(Effect e, int type)
检查e的效果类型（怪兽·魔法·陷阱）是否有type

●int Effect.GetOwnerPlayer(Effect e)
返回OwnerPlayer属性，一般是Owner的控制者

●int Effect.GetHandlerPlayer(Effect e)
返回当前者，一般是Handle的控制者

●bool Effect.IsHasProperty(Effect e, int prop1[, int prop2])
检查效果是否含有标志prop1[和prop2]

●bool Effect.IsHasCategory(Effect e, int cate)
检查效果是否含有效果分类cate

●bool Effect.IsHasType(Effect e, int type)
检查效果是否属于类型type

●bool Effect.IsActivatable(Effect e, int player[, bool neglect_loc=false, bool neglect_target=false])
检查效果e能否由player发动
neglect_loc=true 为不检测发动位置， neglect_target=true 为不检测对象要求

●bool Effect.IsActivated(Effect e)
检查效果e能否是发动的效果，也就是以下类型
EFFECT_TYPE_ACTIVATE		=0x0010		--魔陷发动
EFFECT_TYPE_FLIP			=0x0020		--翻转效果
EFFECT_TYPE_IGNITION		=0x0040		--起动效果
EFFECT_TYPE_TRIGGER_O		=0x0080		--诱发选发效果
EFFECT_TYPE_QUICK_O			=0x0100		--诱发即时效果
EFFECT_TYPE_TRIGGER_F		=0x0200		--诱发必发效果
EFFECT_TYPE_QUICK_F			=0x0400		--诱发即时必发效果（熊猫龙等）

●int Effect.GetActivateLocation(Effect e)
返回效果e的发动区域

●int Effect.GetActivateSequence(Effect e)
返回效果e的发动区域序号

●bool Effect.CheckCountLimit(Effect e, int p)
检测玩家 p 是否还有可以发动的效果 e 的次数

●void Effect.UseCountLimit(Effect e, int p[, int count=1, bool oath_only=false])
手动减少玩家 p 对效果 e 的 count 个可用次数[ oath_only 为 该效果是否是 EFFECT_FLAG_OATH]

●void Effect.SetOwner(Effect e, Card c)
将e的Owner属性设置为c。

●int Effect.GetRange(Effect e)
返回e的Range属性。

●int[,int] Effect.GetCountLimit(Effect e)
返回e的CountLimit属性。

========== Group ==========
●Group Group.CreateGroup()
新建一个空的卡片组

●void Group.KeepAlive(Group g)
让卡片组持续，把卡片组设置为效果的LabelObject需要设置

●void Group.DeleteGroup(Group g)
删除卡片组g

●Group Group.Clone(Group g)
新建卡片组g的副本

●Group Group.FromCards(...)
不定参数，把传入的所有卡组合成一个卡片组并返回，所有参数只能是 Card 类型。没有参数时，相当于Group.CreateGroup()

●void Group.Clear(Group g)
清空卡片组

●void Group.AddCard(Group g, Card c)
往g中增加c

●void Group.RemoveCard(Group g, Card c)
把c从g中移除

●Card Group.GetFirst(Group g)
返回g中第一张卡，并重置当前指针到g中第一张卡
如果g中不存在卡则返回nil

●Card Group.GetNext(Group g)
使指针指向下一张卡并返回这张卡，如果不存在则返回nil

●int Group.GetCount(Group g)
返回g中卡的数量

●int Group.__len(Group g)
和 Group.GetCount 一样

●void Group.ForEach(Group g, function f,...)
以g中的每一张卡作为参数调用一次f ,第三个参数开始为额外参数

●Group Group.Filter(Group g, function f, Card|Group ex|nil, ...)
过滤函数，从g中筛选满足筛选条件f并且不等于ex的卡
从第4个参数开始为额外参数

●int Group.FilterCount(Group g, function f, Card|Group ex|nil, ...)
过滤函数，和Group.Filter基本相同，不同之处在于此函数只返回满足条件的卡的数量

●Group Group.FilterSelect(Group g, int player, function f, int min, int max, Card|Group ex|nil, ...)
过滤函数，让玩家player从g中选择 min-max 张满足筛选条件f并且不等于ex的卡
从第7个参数开始为额外参数

●Group Group.Select(Group g, int player, int min, int max, Card|Group ex|nil)
让玩家player从g中选择min-max张不等于ex的卡

●Card Group.SelectUnselect(Group cg, Group sg, int player, bool btok=false, bool cancelable=false, int minc, int maxc)
让玩家 player 从 cg 中选择 1 张卡放入 sg ，并返回选的卡。  
btok 表示是否可以点击完成选择的按钮， cancelable 表示是否可以取消已选择的卡， 
minc 和 maxc 是客户端的文字缓冲提示，表示需要选择 minc-maxc 张卡，但是这个只是影响视觉效果，并不代表必须要选择那个数量

●Group Group.RandomSelect(Group g, int player, int count)
让玩家player从g中随机选择count张卡
因为是随机选择，所以参数player基本无用，由系统随机选取

●bool Group.IsExists(Group g, function f, int count, Card|Group ex|nil, ...)
过滤函数，检查g中是否存在至少count张满足筛选条件f并且不等于ex的卡
从第5个参数开始为额外参数

●bool Group.CheckWithSumEqual(Group g, function f, int sum, int min=0, int max, ...)
子集求和判定函数，f为返回一个interger值的函数
检查g中是否存在一个数量为min-max的子集满足以f对子集的每一个元素求值的和等于sum，从第6个参数开始为额外参数
	比如：g:CheckWithSumEqual(Card.GetSynchroLevel,7,2,99)
	检查g中是否存在一个子集满足子集的同调用等级之和等于7

●Group Group.SelectWithSumEqual(Group g, int player, function f, int sum, int min, int max, ...)
让玩家player从g中选取一个数量为min-max的子集使子集的特定函数的和等于sum，从第7个参数开始为额外参数

●bool Group.CheckWithSumGreater(Group g, function f, int sum, ...)
子集求和判定函数之二，f为返回一个interger值的函数
检查g中是否存在一个子集满足以f对子集的每一个元素求值的和刚好大于或者等于sum，从第4个参数开始为额外参数
比如：g:CheckWithSumGreater(Card.GetRitualLevel,8)
	检查g中是否存在一个子集满足子集的仪式用等级之和大于等于8
	注：判定必须是“刚好”大于或者等于
	以等级为例，要使等级合计大于等于8，可以选择LV1+LV7而不可以选择LV1+LV4+LV4

●Group Group.SelectWithSumGreater(Group g, int player, function f, int sum, ...)
让玩家player从g中选取一个子集使子集的特定函数f的和大于等于sum，从第5个参数开始为额外参数

●Group,int Group.GetMinGroup(Group g, function f, ...)
f为返回一个interger值的函数，从g中筛选出具有最小的f的值的卡
第2个返回值为这个最小值，从第3个参数开始为额外参数
要使用第2个返回值注意检查g非空

●Group,int Group.GetMaxGroup(Group g, function f, ...)
f为返回一个interger值的函数，从g中筛选出具有最大的f的值的卡
第2个返回值为这个最大值，从第3个参数开始为额外参数
要使用第2个返回值注意检查g非空

●int Group.GetSum(Group g, function f, ...)
计算g中所有卡的取值的总和，f为为每张卡的取值函数，从第3个参数开始为额外参数
等价于：
function GetSum(g,f,...)
	local ct=0
	local val={...}
	for tc in aux.Next(g)
		if f(tc,table.unpack(val)) then ct=ct+1 end
	end
	return ct
end

●int Group.GetClassCount(Group g, function f, ...)
计算g中所有卡的种类数量，f为分类的依据，返回相同的值视为同一种类，从第3个参数开始为额外参数
比如 g:GetClassCount(Card.GetCode()) 就是计算g中卡名不同的卡的数量

●void Group.Remove(Group g, function f, Card ex|nil, ...)
从g中移除满足筛选条件f并且不等于ex的所有卡，第4个参数开始是额外参数

●void Group.Merge(Group g1, Group g2)
把g2中的所有卡合并到g1，若g1中原本就有属于g2的卡，那些卡将不会重复
注：g2本身不会发生变化

●void Group.Sub(Group g1, Group g2)
从g1中移除属于g2中的卡
注：g2本身不会发生变化

●bool Group.Equal(Group g1, Group g2)
判断g1和g2是否相同

●bool Group.IsContains(Group g, Card c)
检查g中是否存在卡片c

●Card Group.SearchCard(Group g, function f, ...)
过滤函数，返回g中满足筛选条件f的第一张卡，若没有则返回nil，从第3个参数开始为额外参数

●int Group.GetBinClassCount(Group g, function f, ...)
和 Group.GetClassCount 类似，但是算法不同(使用位运算)

●Group Group.__add(Group|Card target1, Group|Card target2)
新建一个卡片组，将 targe1 和 target2 中的 全部卡添加到这个卡片组，并返回这个卡片组，若有相同的卡只会添加1次， targe1,target2 本身不会有任何变化

●Group Group.__bor(Group|Card target1, Group|Card target2)
代码和 Group.__add 完全一样

●Group Group.__sub(Group|Card target1, Group|Card target2)
新建一个卡片组，将 targe1 中的 全部卡添加到这个卡片组，然后再从这个卡片组把 target2 的卡全部删除，最后返回这个卡片组，targe1,target2 本身不会有任何变化

●Group Group.__band(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 和 target2 中相同的卡（就是那张卡同时存在于 target1 和 target2 ）全部添加到 这个卡片组里，最后返回这个卡片组，targe1,target2 本身不会有任何变化

●Group Group.__bxor(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 和 target2 中不同的卡（就是只存在于 target1 或者 target2 里的卡）全部添加到 这个卡片组里，最后返回这个卡片组，targe1,target2 本身不会有任何变化

========== Duel ==========
●void Duel.EnableGlobalFlag(int global_flag)
设置全局标记global_flag

●int Duel.GetLP(int player)
返回玩家player的当前LP

●void Duel.SetLP(int player, int lp)
设置玩家player的当前LP为lp

●int Duel.GetTurnPlayer()
返回当前的回合玩家

●int Duel.GetTurnCount([int player])
返回[player所经过的]当前的回合数

●int Duel.GetDrawCount(int player)
返回玩家player每回合的规则抽卡数量

●void Duel.RegisterEffect(Effect e, int player)
把效果e作为玩家player的效果注册给全局环境

●Effect Duel.RegisterFlagEffect(int player, int code, int reset_flag, int property, int reset_count=1[, int label])
为玩家player注册全局环境下的标识效果，并返回这个效果
此效果总是影响玩家的(EFFECT_FLAG_PLAYER_TARGET)并且不会被无效化
其余部分与Card.RegisterFlagEffect相同

●int Duel.GetFlagEffect(int player, int code)
返回玩家 player 的 code 标识效果的数量

●void Duel.ResetFlagEffect(int player, int code)
手动reset玩家player的 code 标识效果

●bool Duel.SetFlagEffectLabel(int player, int code, int label)
返回player是否存在种类为code的标识效果，并设置其Label属性为label

●int Duel.GetFlagEffectLabel(int player, int code)
返回玩家player的种类为code的标识效果的Label，没有此效果则返回nil

●int Duel.Destroy(Card|Group targets, int reason[ ,int dest = LOCATION_GRAVE])
以reason原因破坏targets去dest，返回值是实际被破坏的数量
如果reason包含REASON_RULE，则破坏事件将不会检查卡片是否免疫效果，
不会触发代破效果并且无视“不能破坏”

●int Duel.Remove(Card|Group targets, int pos, int reason)
以reason原因，pos表示形式除外targets，返回值是实际被操作的数量
如果reason包含REASON_TEMPORARY，那么视为是暂时除外，可以通过Duel.ReturnToField返回到场上

●int Duel.SendtoGrave(Card|Group targets, int reason)
以reason原因把targets送去墓地，返回值是实际被操作的数量

●int Duel.SendtoHand(Card|Group targets, int player|nil, int reason)
以reason原因把targets送去玩家player的手牌，返回值是实际被操作的数量
如果player是nil则返回卡的持有者的手牌

●int Duel.SendtoDeck(Card|Group targets, int player|nil, int seq, int reason)
以reason原因把targets送去玩家player的卡组，返回值是实际被操作的数量
如果player是nil则返回卡的持有者的卡组
如果seq=0，则是返回卡组最顶端；seq=1则是返回卡组最底端；
其余情况则是返回最顶端并且标记需要洗卡组

●int Duel.SendtoExtraP(Card|Group targets, int player|nil, int reason)
以reason原因把灵摆卡targets表侧表示送去玩家player的额外卡组，返回值是实际被操作的数量
如果player是nil则返回卡的持有者的额外卡组

●Group Duel.GetOperatedGroup()
此函数返回之前一次卡片操作实际操作的卡片组。包括
Duel.Destroy, Duel.Remove, Duel.SendtoGrave, 
Duel.SendtoHand, Duel.SendtoDeck, Duel.SendtoExtraP, Duel.Release, 
Duel.ChangePosition, Duel.SpecialSummon, Duel.DiscardDeck

●void Duel.Summon(int player, Card c, bool ignore_count, Effect e|nil[, int min=0, int zone=0x1f])
让玩家 player 以效果e对c[在区域 zone]进行通常召唤(非set)，至少使用min个祭品
如果e=nil,那么就按照一般的通常召唤规则进行通常召唤
如果ignore_count=true，则忽略每回合的通常召唤次数限制

●void Duel.SpecialSummonRule(int player, Card c[, int sumtype=0])
让玩家player对c[用 sumtype 方式]进行特殊召唤手续（？）

●void Duel.SynchroSummon(int player, Card c, Card tuner|nil[, Group mg|nil])
让玩家player以tuner作为调整,场上的卡[或mg]为素材，对c进行同调召唤手续

●void Duel.XyzSummon(int player, Card c, Group mg|nil[, min=0, max=0])
让玩家player用场上的卡[或mg][选min-max个素材]对c进行超量召唤手续
mg非空且min为0则直接把mg全部作为超量素材

●void Duel.MSet(int player, Card c, bool ignore_count, Effect e|nil[,int min=0, int zone=0x1f])
让玩家 player 以效果e对c[在区域 zone]进行通常召唤的Set，至少使用min个祭品
如果e=nil,那么就按照一般的通常召唤规则进行通常召唤
如果ignore_count=true，则忽略每回合的通常召唤次数限制

●void|int Duel.SSet(int player, Card|Group targets[, int target_player=player, bool confirm=true])
让玩家player把targets盖放到target_player的魔法陷阱区， confirm 表示是否需要确认
若targets为Group，则返回成功操作的数量

●bool|Card Duel.CreateToken(int player, int code)
根据code新建一个衍生物并返回，该衍生物的拥有者为player，如果 player 不是 0或者1，则返回false

●int Duel.SpecialSummon(Card|Group targets, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone=0xff])
让玩家 sumplayer 以sumtype方式，pos表示形式把targets特殊召唤到target_player场上[的区域 zone]
如果nocheck为true则无视卡的召唤条件，如果nolimit为true则无视卡的苏生限制
返回值是特殊召唤成功的卡的数量

●bool Duel.SpecialSummonStep(Card c, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone=0xff])
此函数是Duel.SpecialSummon的分解过程，只特殊召唤一张卡c ，其他参数用法和 Duel.SpecialSummon 一样
此函数用于一个效果同时特殊召唤多张参数不同的卡
此函数必须和Duel.SpecialSummonComplete一起使用
返回值表示是否特殊召唤成功

●void|int Duel.SpecialSummonComplete()
此函数在确定复数个Duel.SpecialSummonStep调用完毕之后调用，用于触发事件

●bool Duel.IsCanAddCounter(int player, int countertype, int count, Card c)
检查玩家player能否向卡片c添加count个countertype类型的指示物，如果 player 不是 0或者1，则返回false

●bool Duel.RemoveCounter(int player, int s, int o, int countertype, int count, int reason)
让玩家player以reason为原因移除场上存在的countertype类型的count个指示物，返回值表示是否成功
s表示对player来说的己方的可移除指示物的位置，o表示对player来说的对方的可移除指示物的位置

●bool Duel.IsCanRemoveCounter(int player, int s, int o, int countertype, int count, int reason)
检查玩家player以reason为原因是否能移除场上的countertype类型的count个指示物
s表示对player来说的己方的可移除指示物的位置，o表示对player来说的对方的可移除指示物的位置

●int Duel.GetCounter(int player, int s, int o, int countertype)
返回场上存在的countertype类型的指示物的数量
s表示对player来说的己方的可移除指示物的位置，o表示对player来说的对方的可移除指示物的位置

●int Duel.ChangePosition(Card|Group targets, int au[, int ad=au, int du=au, int dd=au, bool noflip=false, bool setavailable=false])
改变targets的表示形式返回实际操作的数量，若只有2个参数，则不管什么表示形式，都变成 第二个参数 代表的形式
表侧攻击表示 = au
里侧攻击表示 = ad
表侧守备表示 = du
里侧守备表示 = dd
如果noflip=true则不触发反转效果（但会触发反转时的诱发效果）
如果setavailable=true则对象之后变成里侧也发动反转效果

●int Duel.Release(Card|Group targets, int reason)
以reason原因解放targets ，返回值是实际解放的数量
如果reason含有REASON_COST，则不会检查卡片是否不受效果影响

●bool Duel.MoveToField(Card c, int move_player, int target_player, int dest, int pos, bool enable)
让玩家move_player把c移动的target_player的场上，返回值表示是否成功
dest只能是LOCATION_MZONE或者LOCATION_SZONE，pos表示可选表示形式， enable 表示是否立刻适用c的效果

●bool Duel.ReturnToField(Card c[, int pos, int zone=0xff])
把c以表示形式pos返回到场上[的区域 zone]，pos默认值是离场前的表示形式，返回值表示是否成功
c必须是以REASON_TEMPORARY原因离场，并且离场后没有离开过那个位置

●void Duel.MoveSequence(Card c, int seq)
移动c的序号，通常用于在场上换格子或者在卡组中移动到最上方或者最下方

●void Duel.SwapSequence(Card c1, Card c2)
交换c1和c2的位置

●void Duel.Activate(Effect e)
发动效果e（？）

●void Duel.SetChainLimit(function f)
设定连锁条件，f的函数原型为 bool f(e,ep,tp)
e表示要限制连锁的效果，ep表示要限制连锁的玩家，tp表示发动该效果的玩家
在cost或者target处理中调用此函数可以限制可以连锁的效果的种类（如超融合）
如果f返回false表示不能连锁，一旦设置连锁条件后发生了新的连锁那么连锁条件将会解除

●void Duel.SetChainLimitTillChainEnd(function f)
功能同Duel.SetChainLimit，但是此函数设定的连锁条件直到连锁结束才会解除

●Effect Duel.GetChainMaterial(int player)
返回玩家player受到的连锁素材的效果，此函数仅用于融合类卡的效果

●void Duel.ConfirmDecktop(int player, int count)
确认玩家player卡组最上方count张卡

●void Duel.ConfirmExtratop(int player, int count)
确认玩家player额外卡组里侧的卡 最上方count张卡

●void Duel.ConfirmCards(int player, Card|Group targets)
给玩家player确认targets

●void Duel.SortDecktop(int sort_player, int target_player, int count)
让玩家sort_player对玩家target_player的卡组最上方count张卡进行排序，最先选的卡在最上面，然后下面是第二张选择的卡，以此类推
最多只能排序16张卡

●bool[,Group,int,int,Effect,int,int] Duel.CheckEvent(int event[, bool get_info])
检查当前是否是event时点
若get_info=true并且是正确的时点，则还返回触发时点的信息 eg,ep,ev,re,r,rp

●void Duel.RaiseEvent(Group|Card eg, int code, Effect re, int r, int rp, int ep, int ev)
以eg,ep,ev,re,r,rp触发一个时点 code

●void Duel.RaiseSingleEvent(Card eg, int code, Effect re, int r, int rp, int ep, int ev)
以eg,ep,ev,re,r,rp为卡片ec触发一个单体时点 code

●bool Duel.CheckTiming(int timing)
检查当前是否是timing提示时点
TIMING_DRAW_PHASE			=0x1			--抽卡阶段时点
TIMING_STANDBY_PHASE		=0x2        	--准备阶段时点
TIMING_MAIN_END				=0x4        	--主要阶段结束时点
TIMING_BATTLE_START			=0x8        	--战斗阶段开始时点
TIMING_BATTLE_END			=0x10       	--战斗阶段结束时点
TIMING_END_PHASE			=0x20       	--结束阶段时点
TIMING_SUMMON				=0x40       	--召唤时点
TIMING_SPSUMMON				=0x80       	--特殊召唤时点
TIMING_FLIPSUMMON			=0x100      	--翻转召唤时点
TIMING_MSET					=0x200			--放置怪兽时点
TIMING_SSET					=0x400      	--放置魔陷时点
TIMING_POS_CHANGE			=0x800      	--表示形式变更时点
TIMING_ATTACK				=0x1000     	--攻击宣言时点
TIMING_DAMAGE_STEP			=0x2000     	--伤害步骤时点
TIMING_DAMAGE_CAL			=0x4000     	--伤害计算时点
TIMING_CHAIN_END			=0x8000     	--连锁结束时点
TIMING_DRAW					=0x10000    	--抽卡时点（不是抽卡阶段
TIMING_DAMAGE				=0x20000    	--造成伤害时点
TIMING_RECOVER				=0x40000		--回复时点
TIMING_DESTROY				=0x80000    	--破坏时点
TIMING_REMOVE				=0x100000   	--除外时点
TIMING_TOHAND				=0x200000   	--加入手牌时点（检索、回收等）
TIMING_TODECK				=0x400000   	--回卡组时点
TIMING_TOGRAVE				=0x800000   	--进墓地时点
TIMING_BATTLE_PHASE			=0x1000000  	--战斗阶段时点
TIMING_EQUIP				=0x2000000  	--装备时点
TIMING_BATTLE_STEP_END		=0x4000000  	--戰鬥步驟結束時

●int,int Duel.GetEnvironment()
返回两个值，表示当前场地代号，以及当前场地效果的来源玩家
场地代号指当前生效的场地卡的代号，或者海神的巫女等卡把场地变化效果的值
来源玩家指当前生效的场地卡的控制者，或者海神的巫女等卡的控制者

●bool Duel.IsEnvironment(int code[, int player=PLAYER_ALL, int loc = LOCATION_FZONE + LOCATION_ONFIELD])
检查场地代号是否是code [，来源玩家是否是 player][，生效区域是否在 loc 内]
场地代号指当前生效的场地卡的代号，或者海神的巫女把场地变化效果的值
来源玩家指当前生效的场地卡的控制者，或者海神的巫女等卡的控制者

●void Duel.Win(int player, int win_reason)
当前效果处理完令player以win_reason决斗胜利

●int Duel.Draw(int player, int count, int reason)
让玩家player以原因reason抽count张卡，返回实际抽的卡的数量
如果reason含有REASON_RULE则此次抽卡不受“不能抽卡”的效果的影响

●int Duel.Damage(int player, int value, int reason[, bool is_step=false])
以reason原因给与玩家player造成value的伤害，返回实际收到的伤害值
如果受到伤害变成回复等效果的影响时，返回值为0.
is_step为true则是伤害/恢复LP过程的分解，需要调用Duel.RDComplete()触发时点

●int Duel.Recover(int player, int value, int reason[, bool is_step=false])
以reason原因使玩家player回复value的LP，返回实际的回复值
如果受到回复变成伤害等效果的影响时，返回值为0.
is_step为true则是伤害/恢复LP过程的分解，需要调用Duel.RDComplete()触发时点

●void Duel.RDComplete()
在调用Duel.Damage/Duel.Recover时，若is_step参数为true，则需调用此函数触发时点

●bool Duel.Equip(int player, Card c1, Card c2[, bool up=true, bool is_step=false])
把c1作为玩家player的装备卡装备给c2，返回值表示是否成功
up=false则保持装备卡之前的表示形式
is_step=true则是装备过程的分解，需要配合Duel.EquipComplete使用

●void Duel.EquipComplete()
在调用Duel.Equip时，若is_step参数为true，则需调用此函数触发时点

●bool Duel.GetControl(Card|Group targets, int player[, int reset_phase=0, int reset_count=0, int zone=0xff])
让玩家 player [直到 reset_count 次 reset_phase 时][在区域 zone]得到 targets 的控制权，返回值表示是否成功
reset_phase ,reset_count 若要使用，必须都用
PHASE_DRAW			=0x01	--抽卡阶段
PHASE_STANDBY		=0x02	--准备阶段
PHASE_MAIN1			=0x04	--主要阶段1
PHASE_BATTLE_START	=0x08	--战斗阶段开始
PHASE_BATTLE_STEP	=0x10	--战斗步驟
PHASE_DAMAGE		=0x20	--伤害步驟
PHASE_DAMAGE_CAL	=0x40	--伤害计算时
PHASE_BATTLE		=0x80	--战斗阶段結束
PHASE_MAIN2			=0x100	--主要阶段2
PHASE_END			=0x200	--结束阶段

●bool Duel.SwapControl(Card|Group targets1, Card|Group targets2[, int reset_phase=0, int reset_count=0])
交换targets1与targets2的控制权，返回值表示是否成功
第三个第四个参数同 Duel.GetControl

●bool Duel.CheckLPCost(int player, int cost)
检查玩家player是否能支付cost点lp

●void Duel.PayLPCost(int player, int cost)
让玩家player支付cost点lp

●int Duel.DiscardDeck(int player, int count, int reason)
以原因reason把玩家player的卡组最上端count张卡送去墓地，返回实际转移的数量

●int Duel.DiscardHand(int player, function f, int min, int max, int reason, Card|Group ex|nil, ...)
过滤函数让玩家player选择并以reason原因丢弃满足筛选条件f兵不等于ex的min-max张手卡
第7个参数开始为额外参数

●void Duel.DisableShuffleCheck([bool disable=true])
使下一个操作不检查是否需要洗切卡组或手卡
注：如果不调用此函数，
除了调用Duel.DiscardDeck和Duel.Draw之外从卡组中取出卡或者把卡加入手卡
或者把卡加入卡组（非最上端或最底端）时，系统会自动在效果处理结束时洗切卡组或手卡
如果不希望如此，比如从卡组顶端除外一张卡等操作，那么需要调用此函数
此函数仅保证紧接着的一次操作不会进行洗卡检测

●void Duel.ShuffleDeck(int player)
手动洗切玩家player的卡组
注：会重置洗卡检测的状态

●void Duel.ShuffleExtra(int player)
手动洗切玩家player的额外卡组

●void Duel.ShuffleHand(int player)
手动洗切玩家player的手卡
注：会重置洗卡检测的状态

●void Duel.ShuffleSetCard(Group g)
洗切覆盖的卡片组 g （实例：魔术礼帽），若g中有表侧表示的卡，则此函数无效
此函数现在可以洗切魔陷区的覆盖卡

●void Duel.ChangeAttacker(Card c[, bool ignore_count=false])
将攻击怪兽变为c
若 ignore_count=true 则原来的攻击怪兽不视为攻击过

●bool Duel.ChangeAttackTarget(Card c|nil)
将攻击对象变为c，c为nil表示直接攻击，返回值表示是否成功转移攻击对象

●void Duel.CalculateDamage(Card c1, Card c2[, bool new_attack=false])
令c1与c2进行战斗伤害计算（c1 攻击 c2）
若 new_attack=true 则视为 攻击的卡进行过攻击宣言（？）

●int Duel.GetBattleDamage(int player)
返回玩家player在本次战斗中受到的伤害

●void Duel.ChangeBattleDamage(int player, int value[, bool check=true])
把玩家player在本次战斗中受到的伤害变成value，若 check=false 则原本战斗伤害就算为0也改变伤害

●void Duel.ChangeTargetCard(int chainc, Group g)
把连锁chainc的对象换成g

●void Duel.ChangeTargetPlayer(int chainc, in player)
把连锁chainc的对象玩家换成player

●void Duel.ChangeTargetParam(int chainc, int param)
把连锁chainc的参数换成param

●void Duel.BreakEffect()
中断当前效果，使之后的效果处理视为不同时处理，此函数会造成错时点

●void Duel.ChangeChainOperation(int chainc, function f)
把连锁chainc的效果的处理函数换成f，用于实现“把效果变成”等的效果
f(e,tp,eg,ep,ev,re,r,rp)

●bool Duel.NegateActivation(int chainc)
使连锁chainc的发动无效，返回值表示是否成功

●bool Duel.NegateEffect(int chainc)
使连锁chainc的效果无效，返回值表示是否成功

●void Duel.NegateRelatedChain(Card c, int reset)
使和卡片c有关的连锁都无效化，发生reset事件则重置,reset 默认包含 RESET_CHAIN

●void Duel.NegateSummon(Card|Group targets)
使正在召唤·反转召唤·特殊召唤的targets的召唤无效

●void Duel.IncreaseSummonedCount([Card c])
手动增加1次玩家[对于卡片c]的已经通常召唤过的次数

●bool Duel.CheckSummonedCount([Card c])
检查回合玩家本回合是否还能通常召唤[卡片c]

●int Duel.GetLocationCount(int player, int location[, int use_player, int reason = LOCATION_REASON_TOFIELD, int zone=0xff])
返回玩家player的场上location可用的[区域 zone 里的]空格数
location只能是LOCATION_MZONE或者LOCATION_SZONE
reason为LOCATION_REASON_TOFIELD或LOCATION_REASON_CONTROL
##第三个第四个额外参数与凯撒斗技场等限制格子的效果有关

●int Duel.GetMZoneCount(int player[, Group|Card targets, int use_player, int reason = LOCATION_REASON_TOFIELD, int zone=0xff])
返回玩家player场上[targets 离开后]可用的[区域 zone 里的]怪兽区数量
##第三个第四个额外参数与凯撒斗技场等限制格子的效果有关

●int Duel.GetLocationCountFromEx(int player[, int reason_player=player, Group|Card targets|nil, Card sc, int zone=0xff])
返回玩家player场上[假如因玩家 reason_player 的原因让 targets 离场后，把卡片 sc 在 zone 区域特殊召唤]可用的 能让额外卡组的怪兽 出场的空格数

●int Duel.GetUsableMZoneCount(int player[, int use_player])
返回玩家player场上[对于 use_player 来说]可用的怪兽区数量（？）

●Group Duel.GetLinkedGroup(int player, int s_range, int o_range)
返回以玩家player来看的 s_range 和 o_range 区域的处于连接状态的卡片组[其实只要后面2个参数不为0就行，只要不为0，都会变成LOCATION_MZONE]（？）

●int Duel.GetLinkedGroupCount(int player, int s_range, int o_range)
返回以玩家player来看的 s_range 和 o_range 区域的处于连接状态的卡片的数量（？）

●int Duel.GetLinkedZone(int player)
返回以玩家player来看的所有连接区域

●Card Duel.GetFieldCard(int player, int location, int seq)
返回玩家player的场上位于location序号为seq的卡，常用于获得场地区域·灵摆区域的卡
注：召唤·反转召唤·特殊召唤 之际 的卡无法获取

●bool Duel.CheckLocation(int player, int location, int seq)
检查玩家player的场上位于location序号为seq的空格是否可用

●int Duel.GetCurrentChain()
返回当前正在处理的连锁序号

●... Duel.GetChainInfo(int chainc, ...)
返回连锁chainc的信息，如果chainc=0，则返回当前正在处理的连锁的信息
此函数根据传入的参数个数按顺序返回相应数量的返回值参数可以是:
CHAININFO_CHAIN_COUNT               连锁序号
CHAININFO_TRIGGERING_EFFECT         连锁的效果
CHAININFO_TRIGGERING_PLAYER         连锁的玩家
CHAININFO_TRIGGERING_CONTROLER      连锁发生位置所属玩家
CHAININFO_TRIGGERING_LOCATION       连锁发生位置
CHAININFO_TRIGGERING_SEQUENCE       连锁发生的位置的序号
CHAININFO_TARGET_CARDS              连锁的对象卡片组
CHAININFO_TARGET_PLAYER             连锁的对象玩家
CHAININFO_TARGET_PARAM              连锁的对象参数
CHAININFO_DISABLE_REASON            连锁被无效的原因效果
CHAININFO_DISABLE_PLAYER            连锁被无效的原因玩家
CHAININFO_CHAIN_ID                  连锁的唯一标识
CHAININFO_TYPE                      连锁卡片的类型（怪兽·魔法·陷阱）
CHAININFO_EXTTYPE                   连锁卡片的具体类型（例如同调怪兽·永续魔法·反击陷阱）
举例：
Duel.GetChainInfo(0,CHAININFO_TRIGGERING_LOCATION,CHAININFO_TARGET_CARDS)
将会返回当前连锁发生的位置和对象卡

●Group,int,int,Effect,int,int Duel.GetChainEvent(int chainc)
返回连锁 chainc 的相关参数，如果 chainc=0，则返回当前正在处理的连锁的相关参数
返回6个参数，eg,ep,ev,re,r,rp

●Card,... Duel.GetFirstTarget()
返回当前连锁的所有的对象卡，一般只有一个对象时使用
##多个对象也能使用，剩下的对象依次按顺序返回，但是很容易记错对象的顺序，所以不建议对多个对象使用

●int Duel.GetCurrentPhase()
返回当前的阶段

●void Duel.SkipPhase(int player, int phase, int reset_flag, int reset_count[, int value])
跳过玩家player的phase阶段，并在特定的阶段后reset，reset参数和效果相同
#value只对phase=PHASE_BATTLE才有用，value=1跳过战斗阶段的结束步骤，用于“变成回合结束阶段”等（招财猫王，闪光弹）

●bool Duel.IsDamageCalculated()
用于在伤害阶段检查是否已经计算了战斗伤害

●Card Duel.GetAttacker()
返回此次战斗攻击的卡

●Card|nil Duel.GetAttackTarget()
返回此次战斗被攻击的卡，如果返回nil表示是直接攻击

●bool Duel.NegateAttack()
无效此次攻击，返回值表示是否成功
此次攻击已经被其他效果无效或导致攻击的卡不能攻击则返回false

●void Duel.ChainAttack([Card c])
使攻击卡[或卡片c]可以再进行1次攻击（比如 大开辟，破灭的女王）

●void Duel.Readjust()
刷新场上的卡的信息
非特定情况或者不清楚原理请勿使用此函数以免形成死循环

●void Duel.AdjustInstantly([Card c])
手动刷新场上[受到卡片c影响]的卡的无效状态

●Group Duel.GetFieldGroup(int player, int s, int o)
返回以player来看的指定位置的卡，s代表以player来看的自己的位置，o代表以player来看的对方的位置

●int Duel.GetFieldGroupCount(int player, int s, int o)
同 Duel.GetFieldGroup ，只是返回的是卡的数量

●Group Duel.GetDecktopGroup(int player, int count)
返回玩家player的卡组最上方的count张卡

●Group Duel.GetExtraTopGroup(int player, int count)
返回玩家player的额外卡组表侧表示的卡中最上方的count张卡

●Group Duel.GetMatchingGroup(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以player来看的指定位置满足过滤条件f并且不等于ex的卡
s代表以player来看的自己的位置，o代表以player来看的对方的位置
第6个参数开始为额外参数

●int Duel.GetMatchingGroupCount(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以player来看的指定位置满足过滤条件f并且不等于ex的卡的数量
s代表以player来看的自己的位置，o代表以player来看的对方的位置
第6个参数开始为额外参数

●Card Duel.GetFirstMatchingCard(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以player来看的指定位置满足过滤条件f并且不等于ex的第一张卡,没有则返回nil
s代表以player来看的自己的位置，o代表以player来看的对方的位置
第6个参数开始为额外参数

●bool Duel.IsExistingMatchingCard(function f|nil, int player, int s, int o, int count, Card|Group ex|nil, ...)
过滤函数，检查以player来看的指定位置是否存在至少count张满足过滤条件f并且不等于ex的卡
s代表以player来看的自己的位置，o代表以player来看的对方的位置
第7个参数开始为额外参数

●Group Duel.SelectMatchingCard(int sel_player, function f|nil, int player, int s, int o, int min, int max, Card|Group ex|nil, ...)
过滤函数，让玩家sel_player选择以player来看的指定位置满足过滤条件f并且不等于ex的min-max张卡
s代表以player来看的自己的位置，o代表以player来看的对方的位置
第9个参数开始为额外参数

●Group Duel.GetReleaseGroup(int player[, bool use_hand=false])
返回玩家player可解放（非上级召唤用）的卡片组， use_hand=true 则包括手卡

●integer Duel.GetReleaseGroupCount(int player[, bool use_hand=false])
返回玩家player可解放（非上级召唤用）的卡片数量， use_hand=true 则包括手卡

●bool Duel.CheckReleaseGroup(int player, function f|nil, int count, Card|Group ex|nil, ...)
检查玩家player场上是否存在至少count张满足过滤条件f并且不等于ex的可解放的卡（非上级召唤用）
第5个参数开始为额外参数

●Group Duel.SelectReleaseGroup(int sel_player, function f|nil, int min, int max, Card|Group ex|nil, ...)
过滤函数，让玩家sel_player从场上选择min-max张不等于ex的满足条件f的可解放的卡（非上级召唤用）
第6个参数开始为额外参数

●bool Duel.CheckReleaseGroupEx(int player, function f|nil, int count, Card|Group ex|nil, ...)
检查玩家player场上·手卡是否存在至少count张满足过滤条件f并且不等于ex的可解放的卡（非上级召唤用）
第5个参数开始为额外参数

●Group Duel.SelectReleaseGroupEx(int player, function f|nil, int min, int max, Card|Group ex|nil, ...)
过滤函数，让玩家player从场上·手卡选择min-max张满足过滤条件f并且不等于ex的可解放的卡（非上级召唤用）
第6个参数开始为额外参数

●Group Duel.GetTributeGroup(Card c)
返回场上用于通常召唤c可解放（上级召唤用）的卡片组

●int Duel.GetTributeCount(Card c[, Group mg, bool ex=false])
返回场上[或mg中]用于通常召唤c的祭品数量，ex=true则允许对方场上的怪兽（太阳神之翼神龙-球体形）
此数量不一定等于Duel.GetTributeGroup的返回值中的卡片数量
因为某些卡可以作为多个祭品来使用

●Group Duel.CheckTribute(Card c, int min[, int max=min|nil, Group mg|nil, int toplayer=c:GetControler()|nil, int zone=0x1f|nil])
判断场上[或mg中]是否存在用于通常召唤c[到toplayer场上的区域 zone]的min[到max]个祭品

●Group Duel.SelectTribute(int player, Card c, int min, int max[, Group mg|nil, int toplayer=c:GetControler()|nil])
让玩家player从场上[或mg中]选择用于通常召唤c的min-max个祭品，召唤到 toplayer 场上

●int Duel.GetTargetCount(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
基本同Duel.GetMatchingGroupCount ，不同之处在于需要追加判定卡片是否能成为当前正在处理的效果的对象

●bool Duel.IsExistingTarget(function f|nil, int player, int s, int o, int count, Card|Group ex|nil, ...)
基本同Duel.IsExistingMatchingCard ，不同之处在于需要追加判定卡片是否能成为当前正在处理的效果的对象

●Group Duel.SelectTarget(int sel_player, function f|nil, int player, int s, int o, int min, int max, Card|Group ex|nil, ...)
基本同Duel.SelectMatchingCard ，不同之处在于此函数会同时将当前正在处理的连锁的对象设置成选择的卡

●Group Duel.SelectFusionMaterial(int player, Card c, Group g[, Card gc|nil, int chkf=PLAYER_NONE])
让玩家player从g中选择一组[必须包含gc在内的]融合怪兽c的融合素材
##根据c的种类为EFFECT_FUSION_MATERIAL的效果的Operation操作

●void Duel.SetFusionMaterial(Group g)
设置g为需要使用的融合素材

●void Duel.SetSynchroMaterial(Group g)
设置g为需要使用的同调素材

●Group Duel.SelectSynchroMaterial(int player, Card c, function f1|nil, function f2|nil, int min, int max[, Card smat|nil, Group mg|nil])
让玩家player从场上[或mg中]选择用于同调c需要的[必须包含smat在内（如果有mg~=nil则忽略此参数）]满足条件的一组素材
f1是 1 只需要满足的过滤条件，f2是 min-max 只需要满足的过滤条件
f1,f2 之中，至少有一种为调整的条件

●bool Duel.CheckSynchroMaterial(Card c, function f1|nil, function f2|nil, int min, int max[, Card smat|nil, Group mg|nil])
检查场上[或mg中]是否存在一组[必须包括smat在内的（如果有mg~=nil则忽略此参数）]满足条件的卡作为同调召唤c的素材
f1是 1 只需要满足的过滤条件，f2是 min-max 只需要满足的过滤条件
f1,f2 之中，至少有一种为调整的条件

●Group Duel.SelectTunerMaterial(int player, Card c, Card tuner, function f1|nil, function f2|nil, int min, int max[, Group mg|nil])
让玩家从场上[或mg中]选择用于同调c需要的满足条件的以tuner作为调整的min-max张卡的一组素材
f1是 1 只需要满足的过滤条件，f2是 min-max 只需要满足的过滤条件

●bool Duel.CheckTunerMaterial(Card c, Card tuner, function f1|nil, function f2|nil, int min, int max[, Group mg|nil])
检查场上[或mg中]是否存在一组以tuner作为调整,并且满足条件的卡作为同调召唤c的素材
f1是 1 只需要满足的过滤条件，f2是 min-max 只需要满足的过滤条件

●Group Duel.GetRitualMaterial(int player)
返回玩家player可用的用于仪式召唤素材的卡片组
包含手上，场上可解放的以及墓地的仪式魔人等卡

●void Duel.ReleaseRitualMaterial(Group g)
解放仪式用的素材g，如果是墓地的仪式魔人等卡则除外

●Group Duel.GetFusionMaterial(int player)
返回玩家player可用的用于融合召唤素材的卡片组
包含手卡·场上的怪兽的以及受 EFFECT_EXTRA_FUSION_MATERIAL 影响的卡

●void Duel.SetSelectedCard(Card|Group cards)
将cards设置为Group.SelectWithSumEqual或Group.SelectWithSumGreater已选择的卡片（？）

●void Duel.SetTargetCard(Card|Group targets)
把当前正在处理的连锁的对象设置成targets
注，这里的对象指的的广义的对象，包括不取对象的效果可能要处理的对象

●void Duel.ClearTargetCard()
把当前正在处理的连锁的对象全部清除

●void Duel.SetTargetPlayer(int player)
把当前正在处理的连锁的对象玩家设置成player

●void Duel.SetTargetParam(inte param)
把当前正在处理的连锁的对象参数设置成param

●void Duel.SetOperationInfo(int chainc, int category, Card|Group targets, int count, int target_player, int target_param)
设置当前处理的连锁的操作信息此操作信息包含了效果处理中确定要处理的效果分类
比如潜行狙击手需要设置CATEGORY_DICE，但是不能设置CATEGORY_DESTROY，因为不确定
对于破坏效果，targets需要设置成发动时可能成为连锁的影响对象的卡，
并设置count为发动时确定的要处理的卡的数量
比如黑洞发动时，targets需要设定为场上的所有怪兽，count设置成场上的怪的数量
对于需要移动卡片位置的CATEGORY_SPECIAL_SUMMON,CATEGORY_TOHAND,CATEGORY_TODECK等分类，
如果要处理的卡是确定的（比如取对象），则设置targets为这些卡，count为数量，
如果要处理的卡是不确定的（效果处理时才能确定，一般是不取对象的效果），
	则设置targets为nil，count为预计要处理的卡的数量，
	target_player为预计要处理的卡的持有者（不确定就为0）
	target_param为预计要处理的卡的位置
例如增援：SetOperationInfo(0,CATEGORY_TOHAND,nil,1,tp,LOCATION_DECK)
操作信息用于很多效果的发动的检测，例如星尘龙，王家长眠之谷等

●bool[,Card|Group,int,int,int] Duel.GetOperationInfo(int chainc, int category)
返回连锁chainc的category分类的操作信息，存在的话，则返回值为5个， chainc=0 则是表示当前连锁
第一个返回值是false的话表示不存在该分类
后4个返回值对应Duel.SetOperationInfo的后4个参数：Card|Group targets, int count, int target_player, int target_param

●int Duel.GetOperationCount(int chainc)
返回连锁chainc包含的操作分类的数量

●bool Duel.CheckXyzMaterial(Card c, function f|nil, int lv, int min, int max, Group mg|nil)
检查场上[或mg中]是否存在超量召唤c的超量用等级为lv的min-max个满足条件f的叠放素材

●Group Duel.SelectXyzMaterial(int player, Card c, function f|nil, int lv, int min, int max[, Group mg|nil])
让玩家player为超量怪兽c从场上[或mg中]选择超量用等级为lv的min-max个满足条件f的叠放素材

●void Duel.Overlay(Card c, Card|Group ocard)
把ocard作为c的叠放卡叠放

●Group Duel.GetOverlayGroup(int player, int s, int o)
返回以player来看的指定位置的所有叠放的卡
s代表以player来看的自己的位置，o代表以player来看的对方的位置

●int Duel.GetOverlayCount(int player, int s, int o)
返回以player来看的指定位置的所有叠放的卡的数量
s代表以player来看的自己的位置，o代表以player来看的对方的位置

●bool Duel.CheckRemoveOverlayCard(int player, int s, int o, int count, int reason)
检查player能否以原因reason移除以player来看的指定位置至少count张卡
s代表以player来看的自己的位置，o代表以player来看的对方的位置

●bool Duel.RemoveOverlayCard(int player, int s, int o, int min, int max, int reason)
让player以reason原因移除以player来看的指定位置的min-max张叠放卡，返回值表示是否成功
s代表以player来看的自己的位置，o代表以player来看的对方的位置

●void Duel.Hint(int hint_type, int player, int desc)
给玩家player发送hint_type类型的消息提示，提示内容为desc
#hint_type只能为以下类型：
#HINT_SELECTMSG		将提示内容写入缓存，用于选择卡片的提示，例如Duel.SelectMatchingCard等
#HINT_OPSELECTED	向player提示“对方选择了：...”，常用于向对方玩家提示选择发动了什么效果
#HINT_CARD			此时desc应为卡号，手动显示卡片发动的动画，常用于提示不入连锁的处理
#HINT_RACE			此时desc应为种族，向player提示“对方宣言了：...”种族
#HINT_ATTRIB		此时desc应为属性，向player提示“对方宣言了：...”属性
#HINT_CODE			此时desc应为卡号，向player提示“对方宣言了：...”卡片
#HINT_NUMBER		此时desc视为单纯的数字，向player提示“对方选择了：...”数字
#HINT_MESSAGE		弹出一个对话框显示信息
#HINT_EVENT			将提示内容写入缓存，用于时点的提示信息（诱发即时效果的提示）
#HINT_EFFECT		同HINT_CARD

●void Duel.HintSelection(Group g)
手动为g显示被选为对象的动画效果，并记录这些卡被选为对象(广义的)

●bool Duel.SelectEffectYesNo(int player, Card c[, int desc=95])
让玩家player选择是否发动卡片c的效果[提示文字可以自行用desc替换，desc 用 aux.Stringid 获取]

●bool Duel.SelectYesNo(int player, int desc)
让玩家player选择是或否

●int Duel.SelectOption(int player, int desc1, ...)
让玩家选择选项，从第二个参数开始，每一个参数代表一条选项
返回选择的选项的序号(从0开始)

●void Duel.SelectSequence()
 此函数只有一个 check_action_permission 操作，不知何用

●int Duel.SelectPosition(int player, Card c, int pos)
让玩家player选择c的表示形式并返回

●int Duel.SelectDisableField(int player, int count, int s, int o, int filter)
让玩家player选择指定位置满足标记条件filter的count个可用的空格，并返回选择位置的标记
常用于选择区域不能使用或移动怪兽格子
##位置标记的定义如下
##flag = 0;
##seq为在玩家p，位置l中选择的格子序号
##for(int32 i = 0; i < count; ++i) {
##	flag |= 1 << (seq[i] + (p[i] == player ? 0 : 16) + (l[i] == LOCATION_MZONE ? 0 : 8));
##}

●int Duel.AnnounceRace(int player, int count, int available)
让玩家player从可选的种族中宣言count个种族
available是所有可选种族的组合值，可以自行组合
RACE_ALL			=0x1ffffff	--全种族
RACE_WARRIOR		=0x1		--战士
RACE_SPELLCASTER	=0x2		--魔法师
RACE_FAIRY			=0x4		--天使
RACE_FIEND			=0x8		--恶魔
RACE_ZOMBIE			=0x10		--不死
RACE_MACHINE		=0x20		--机械
RACE_AQUA			=0x40		--水
RACE_PYRO			=0x80		--炎
RACE_ROCK			=0x100		--岩石
RACE_WINDBEAST		=0x200		--鸟兽
RACE_PLANT			=0x400		--植物
RACE_INSECT			=0x800		--昆虫
RACE_THUNDER		=0x1000		--雷
RACE_DRAGON			=0x2000		--龙
RACE_BEAST			=0x4000		--兽
RACE_BEASTWARRIOR	=0x8000		--兽战士
RACE_DINOSAUR		=0x10000	--恐龙
RACE_FISH			=0x20000	--鱼
RACE_SEASERPENT		=0x40000	--海龙
RACE_REPTILE		=0x80000	--爬虫类
RACE_PSYCHO			=0x100000	--念动力
RACE_DEVINE			=0x200000	--幻神兽
RACE_CREATORGOD		=0x400000	--创造神
RACE_WYRM			=0x800000	--幻龙
RACE_CYBERSE		=0x1000000	--电子界

●int Duel.AnnounceAttribute(int player, int count, int available)
让玩家player从可选的属性中宣言count个属性
available是所有可选属性的组合值，可以自行组合
ATTRIBUTE_EARTH		=0x01		--地
ATTRIBUTE_WATER		=0x02		--水
ATTRIBUTE_FIRE		=0x04		--炎
ATTRIBUTE_WIND		=0x08		--风
ATTRIBUTE_LIGHT		=0x10		--光
ATTRIBUTE_DARK		=0x20		--暗
ATTRIBUTE_DEVINE	=0x40		--神

●int Duel.AnnounceLevel(int player[, int min=1|nil, int max=12|nil, ...])
让玩家宣言一个[min-max]等级并返回

●int Duel.AnnounceCard(int player[, int type=(TYPE_MONSTER | TYPE_SPELL | TYPE_TRAP)])
让玩家player宣言一个[type类型的]卡片代号（比如：禁止令）

●int Duel.AnnounceCardFilter(int player, ...)
让玩家player宣言一个满足条件的卡片代号，条件是额外参数，并且都是 int 类型，用于宣言某些特定范围的卡
例如：虚空俏丽魔术师
c28776350.announce_filter={TYPE_FUSION+TYPE_SYNCHRO+TYPE_XYZ+TYPE_LINK,OPCODE_ISTYPE,OPCODE_NOT}
local ac=Duel.AnnounceCardFilter(tp,table.unpack(c28776350.announce_filter))
因为主卡组里不可能存在 TYPE_FUSION, TYPE_SYNCHRO, TYPE_XYZ, TYPE_LINK 这些类型的卡，所以将它们排除在可以宣言的卡名里。
虽然直接用 Duel.AnnounceCard 也行，但是这种写法可以避免无意义宣言

●int Duel.AnnounceType(int player[, int antype=70|71|72])
让玩家player宣言一个卡片类型（怪兽·魔法·陷阱）
别想着直接宣言 复合类型（永续魔法 等）

●int,int Duel.AnnounceNumber(int player, int number, ...)
让玩家player宣言一个数字
从第二个参数开始，每一个参数代表一个可宣言的数字
第一个返回值是宣言的数字，第二个返回值是宣言数字在所有选项中的位置

●int Duel.AnnounceCoin(int player[, int antype=60|61])
让玩家player宣言硬币的正反面

●... Duel.TossCoin(int player, int count)
让玩家player投count(<=5)次硬币，返回值为count个结果，0或者1, 正面是 1，反面是0

●... Duel.TossDice(int player, int count1[, int count2 = 0])
让玩家player投count1次骰子[，1-player投count2次骰子](count1+count2<=5)
返回值为count1+count2个结果，1-6

●int Duel.RockPaperScissors([bool repeat=true])
猜拳，若 repeat=false 则只猜一次；否则就是直到分出胜负为止。返回胜利的玩家号码

●int,int,int,int,int Duel.GetCoinResult()
返回当前投硬币的结果

●int,int,int,int,int Duel.GetDiceResult()
返回当前掷骰子的结果

●void Duel.SetCoinResult(int res, ... )
强行修改投硬币的结果为res ,最多5个参数，res只能是 0 或 1, ，其他全算作 0
此函数用于永续的EVENT_TOSS_COIN事件中

●void Duel.SetDiceResult(int res, ...)
强行修改投骰子的结果为res ,最多5个参数，res只能是 1~255, ，其他数字全算作 1
此函数用于永续的EVENT_TOSS_DICE事件中

●Effect|nil,... Duel.IsPlayerAffectedByEffect(int player, int code)
检查player是否受到种类为code的效果影响，如果有就返回该效果，没有则返回nil

●bool Duel.IsPlayerCanDraw(int player[, int count=0])
检查玩家player是否可以效果抽[count张]卡

●bool Duel.IsPlayerCanDiscardDeck(int player, int count)
检查玩家player是否可以把卡组顶端count张卡送去墓地

●bool Duel.IsPlayerCanDiscardDeckAsCost(int player, int count)
检查玩家player能否把卡组顶端count张卡送去墓地作为cost

●bool Duel.IsPlayerCanSummon(int player[, int sumtype, Card c])
检查玩家player是否可以通常召唤[c，以sumtype方式]
如果需要可选参数，则必须全部使用
仅当玩家收到“不能上级召唤”等效果的影响时返回false

●bool Duel.IsPlayerCanSpecialSummon(int player[, int sumtype, int sumpos, int target_player, Card c])
检查玩家player能否特殊召唤[c到target_player场上，以sumtype召唤方式，sumpos表示形式]
如果需要可选参数，则必须全部使用

●bool Duel.IsPlayerCanFlipSummon(int player, Card c)
检查玩家player是否可以反转召唤c

●bool Duel.IsPlayerCanSpecialSummonMonster(int player, int code[, int setcode|nil, int type|nil, int atk|nil, int def|nil, int level|nil, int race|nil, int attribute|nil, int  pos=POS_FACEUP, int target_player=player, int sumtype=0])
检查玩家player是否可以[以sumtype 方式][以 pos 表示形式]特殊召唤 给定参数的怪兽到target_player场上
此函数通常用于判定是否可以特招token和陷阱怪兽

●bool Duel.IsPlayerCanSpecialSummonCount(int player, int count)
检查玩家player能否特殊召唤count次

●bool Duel.IsPlayerCanRelease(int player, Card c)
检查玩家player是否能解放c

●bool Duel.IsPlayerCanRemove(int player, Card c)
检查玩家player是否能除外c

●bool Duel.IsPlayerCanSendtoHand(int player, Card c)
检查玩家是否能把c送去手牌

●bool Duel.IsPlayerCanSendtoGrave(int player, Card c)
检查玩家是否能把c送去墓地

●bool Duel.IsPlayerCanSendtoDeck(int player, Card c)
检查玩家是否能把c送去卡组

●bool Duel.IsPlayerExtraSummoned(int player)
检查玩家是否进行过额外的通常召唤

●bool Duel.IsChainNegatable(int chainc)
检查连锁chainc的发动能否被无效

●bool Duel.IsChainDisablable(int chainc)
检查连锁chainc的效果能否被无效

●bool Duel.CheckChainTarget(int chainc, Card c)
检查c是否是连锁chainc的效果的正确的对象

●bool Duel.CheckChainUniqueness()
检查当前连锁中是否存在同名卡的发动，返回true表示无同名卡

●int,... Duel.GetActivityCount(int player, int activity_type, ...)
返回player进行对应的activity_type操作的次数
activity_type为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的放置）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的放置）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_BATTLE_PHASE   =6	--进入战斗阶段

●bool Duel.CheckPhaseActivity()
检查玩家在当前阶段是否有操作（是否处于阶段开始时，如七皇之剑）

●void Duel.AddCustomActivityCounter(int counter_id, int activity_type, function f)
设置操作类型为activity_type、代号为counter_id的计数器，放在initial_effect函数内
f为过滤函数，以Card类型为参数，返回值为false的卡片进行以下类型的操作，计数器增加1（目前最多为1）
activity_type为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的set）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的set）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_CHAIN          =7	--发动效果

●int Duel.GetCustomActivityCount(int counter_id, int player, int activity_type)
代号为counter_id的计数器的计数，返回player进行以下操作的次数（目前最多为1）
activity_type为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的set）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的set）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_CHAIN          =7	--发动效果

●int Duel.GetBattledCount(int player)
返回玩家player这回合战斗过的次数 

●bool Duel.IsAbleToEnterBP()
检查回合玩家能否进入战斗阶段

#●bool Duel.VenomSwampCheck(Effect e, Card c)
#蛇毒沼泽专用。把攻击力被其效果变成0的卡片破坏

●void Duel.SwapDeckAndGrave(int player)
现世与冥界的逆转专用。把玩家player的卡组和墓地交换

●void Duel.MajesticCopy(Card c1, Card c2)
救世星龙专用。把c2记述的效果复制给c1
强制发动的效果可以选择是否发动

●int Duel.GetMasterRule()
返回当前决斗规则（大师规则X）。

●int,int,.. Duel.ReadCard(int|Card target, int type, int type2, ..)
返回卡片target（或是卡号为target的卡）的type的信息。
type可以是以下之一：
CARDDATA_CODE			1
CARDDATA_ALIAS			2
CARDDATA_SETCODE		3
CARDDATA_TYPE			4
CARDDATA_LEVEL			5
CARDDATA_ATTRIBUTE		6
CARDDATA_RACE			7
CARDDATA_ATTACK			8
CARDDATA_DEFENSE		9
CARDDATA_LSCALE			10
CARDDATA_RSCALE			11
CARDDATA_LINK_MARKER	12

●int Duel.Exile(Card|Group target, int reason)
以reason的原因把target直接消灭。返回被消灭的卡的数量。

●void Duel.DisableActionCheck(bool enabled)
打开或关闭DisableActionCheck模式。
在DisableActionCheck模式下，可以在禁止进行决斗操作的处理（如condition以及target的chk==0的部分）进行决斗操作，不会出现Action is not allowed的报错。

●void Duel.SetMetatable(Card|Group|Effect target, table mt)
将target的元表属性设置为mt。
此函数用途和lua内置函数setmetatable相同，只是针对YGOPro内的userdata属性而设计的。

●void Duel.MoveTurnCount()
把回合数直接向前推进1回合。此操作会改变双方的客户端显示，以及加时赛的处理。

●Group Duel.GetCardsInZone(int player, int zone)
获取以player的视野，zone区域的所有卡。

●bool Duel.XyzSummonByRose(int player, Card xyzcard, Card c1, Card c2)
用c1和c2这2张卡为素材把xyzcard超量召唤。超量召唤时，c1的等级当作和c2相同。

●void Duel.LoadScript(string filename)
加载文件名是filename的脚本。该函数会自动在脚本目录下搜索脚本文件进行加载。

========== aux ============
##只说明常用的函数
●int aux.Stringid(int code, int id)
用于索引卡号为code的卡片第id个（从0开始）效果提示

●Card aux.Next(Group g)
卡片组 g 的迭代器，指针会先指向第一张卡，然后每次调用这函数指向下一张卡，通常用在需要对g中的卡片进行操作的时候
例如：
	local g=Group.CreateGroup()
	for tc in aux.Next(g) do
	end
等价于：
	local g=Group.CreateGroup()
	local tc=g:GetFirst()
	while tc do
		tc=g:GetNext()
	end

●void aux.BeginPuzzle()
开始残局
##此函数注册3个全局效果：
##回合结束时玩家的基本分变成0
##跳过抽卡阶段与准备阶段

●bool aux.IsDualState(Effect e)
检查二重怪兽e:GetHandler()是否是再度召唤状态（用于效果的Condition属性）
常用于二重怪兽再度召唤获得的效果e的Condition属性

●bool aux.IsNotDualState(Effect e)
aux.IsDualState的反义（用于效果的Condition属性）

●bool aux.DualNormalCondition(Effect e)
检查二重怪兽e:GetHandler()是否为被视为通常怪兽的状态（用于效果的Condition属性）

●void aux.EnableDualAttribute(Card c)
为c添加二重怪兽属性

●void aux.EnableSpiritReturn(Card c, int event1,...)
为c添加灵魂怪兽结束阶段回到手卡的效果（发生事件event1,...的回合，结束阶段回到手卡）

●bool aux.IsUnionState(Effect e)
检查同盟怪兽e:GetHandler()是否处于同盟装备的状态（用于效果的Condition属性）

●void aux.SetUnionState(Card c)
为c添加同盟怪兽属性

●bool aux.CheckUnionEquip(Card uc, Card tc)
检查同盟怪兽uc能否作为同盟装备在怪兽tc上

●function Auxiliary.TargetEqualFunction(function f, any value, ...)
一般用在效果注册里,返回的是一个 有 bool 返回值类型的 函数，第3个参数开始为额外参数
function Auxiliary.TargetEqualFunction(f,value,...)
	local ext_params={...}
	return	function(effect,target)
				return f(target,table.unpack(ext_params))==value
			end
end

●function Auxiliary.TargetBoolFunction(function f,...)
一般用在效果注册里,返回的是一个 有 bool 返回值类型的 函数，第2个参数开始为额外参数
function Auxiliary.TargetBoolFunction(f,...)
	local ext_params={...}
	return	function(effect,target)
				return f(target,table.unpack(ext_params))
			end
end

●function aux.FilterEqualFunction(function f, any value, ...)
用于过滤满足单一过滤条件 f ,且值为 value 的卡,,返回的是一个 有 bool 返回值类型的 函数， 第3个参数开始为额外参数
function Auxiliary.FilterEqualFunction(f,value,...)
	local ext_params={...}
	return	function(target)
				return f(target,table.unpack(ext_params))==value
			end
end

●function aux.FilterBoolFunction(function f, ...)
用于过滤满足单一过滤条件 f 的卡,,返回的是一个 有 bool 返回值类型的 函数，第2个参数开始为额外参数
function Auxiliary.FilterBoolFunction(f,...)
	local ext_params={...}
	return	function(target)
				return f(target,table.unpack(ext_params))
			end
end

●function aux.Tuner(function f, ...)
用于过滤满足单一过滤条件 f 的调整，,返回的是一个 有 bool 返回值类型的 函数，只要求是 调整怪兽的话，就写 aux.Tuner(nil)
第2个参数开始为额外参数

●function aux.NonTuner(function f, ...)
用于过滤满足单一过滤条件 f 的调整以外的卡，,返回的是一个 有 bool 返回值类型的 函数，只要求是 调整以外的怪兽的话，就写 aux.NonTuner(nil)
第2个参数开始为额外参数

●Card|Group|Effect|int|bool|string|nil|function|table|any aux.GetValueType(any value)
返回 value 在lua中的type

●Group aux.GetMustMaterialGroup(int player , int code)
如果 player 受到效果种类 code 影响，则返回受到影响的卡
目前代码中涉及的code有 EFFECT_MUST_BE_SMATERIAL, EFFECT_MUST_BE_XMATERIAL, EFFECT_MUST_BE_FMATERIAL, EFFECT_MUST_BE_LMATERIAL ,都是 必须成为素材的效果

●bool aux.MustMaterialCheck(Card|Group value, int player , int code)
检查 value 中是否有 player 受到效果种类 code 影响的卡或者卡片组
目前代码中涉及的code有 EFFECT_MUST_BE_SMATERIAL, EFFECT_MUST_BE_XMATERIAL, EFFECT_MUST_BE_FMATERIAL, EFFECT_MUST_BE_LMATERIAL ,都是 必须成为素材的检测

●bool aux.MustMaterialCounterFilter(Card c, Group g)
如果 g 中 包含 c ，则返回 false

●void aux.AddSynchroProcedure(Card c, function f1|nil, function f2|nil, int minc[, int maxc=99])
为c添加同调召唤手续
f1为 1 只满足的过滤条件，并且必须为调整；f2为 minc [~ maxc]只满足的过滤条件

●void aux.AddSynchroProcedure2(Card c, function f1, function f2)
等价于aux.AddSynchroProcedure(c,f1,f2,1,1)

●void aux.AddSynchroMixProcedure(Card c, function f1|nil, function f2|nil, function f3|nil, function f4|nil, int minc, int maxc)
为c添加同调召唤手续，
f1,f2,f3 为 1 只满足的过滤条件，f4为 minc [~ maxc]只满足的过滤条件
f1,f2,f3,f4 之中，至少有一种为调整
f2 和 f3 若为nil，则等价于aux.AddSynchroProcedure(c,f1,f4,minc[, maxc])

●function aux.TuneMagicianFilter(Card c, Effect e)
调弦之魔术师(73941492)专用，,返回的是一个 有 bool 返回值类型的 函数 f(e,c)

●function aux.TuneMagicianCheckX(Card c, Group sg, Effect e)
调弦之魔术师(73941492)专用

●void aux.AddXyzProcedure(Card c, function f|nil, int lv, int ct[, function alterf|nil, int desc|nil, int maxc=ct, function op|nil])
为c添加超量召唤手续
用满足条件 f 的等级为 lv 的 ct[-maxc] 只怪兽进行叠放
或者在单个怪兽（通常是超量怪兽）上叠放
alterf 为这个怪兽满足的条件，desc为描述，op为叠放时需要的操作（比如 希望皇龙）

●void aux.AddXyzProcedureLevelFree(Card c, function f|nil, function gf|nil, int minc, int maxc[, function alterf|nil, int desc|nil, function op|nil])
为c添加超量召唤手续
用满足条件 f 的卡片组里，满足 gf 的 minc[-maxc] 只怪兽进行叠放，f 为必要条件，gf 为额外条件
或者在单个怪兽（通常是超量怪兽）上叠放
alterf为这个怪兽满足的条件，desc为描述，op为叠放时需要的操作（比如 闪光No.0 希望之异热同心）

●void aux.AddFusionProcMix(Card c, bool sub, bool insf, ...)
为c 添加融合召唤手续
用额外参数里的卡各1张为融合素材,额外参数的类型 可以是 function 或者 卡密(int code),传入 code 相当于传入 function(code) return c:IsFusionCode(code) end
sub表示能否使用融合代替素材，insf 为false表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
#以下融合函数这2个参数相同

●void aux.AddFusionProcMixRep(Card c, bool sub, bool insf, (function f1)|(int code1), int minc, int maxc, ...)
为c 添加融合召唤手续
用满足f1 的怪兽 minc-maxc 只，和 额外参数里 各1只的怪兽为融合素材,
额外参数的类型 可以是 function 或者 卡密(int code),传入 code 相当于传入 function(code) return c:IsFusionCode(code) end

●void aux.AddFusionProcCode2(Card c, int code1, int code2, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1和code2的2只怪兽为融合素材
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2)

●void aux.AddFusionProcCode3(Card c, int code1, int code2, int code3, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1,code2,code3的3只怪兽为融合素材
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2,code3)

●void aux.AddFusionProcCode4(Card c, int code1, int code2, int code3, int code4, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1,code2,code3,code4的4只怪兽为融合素材
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2,code4)

●void aux.AddFusionProcCodeRep(Card c, int code, int cc, bool sub, bool insf)
为c 添加融合召唤手续
用 cc 个相同的怪兽为融合素材，code为卡号
等价于 aux.AddFusionProcMix(c,sub,insf,table.unpack(tcode)) ,tcode 是包含 cc 个 code 的表

●void aux.AddFusionProcCodeRep2(Card c, int code, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用 minc-maxc 个相同的怪兽为融合素材，code为卡号
等价于 aux.AddFusionProcMixRep(c,sub,insf,code1,minc,maxc)

●void aux.AddFusionProcCodeFun(Card c, int code, function f, int cc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号号为 code 的1只怪兽，和 cc 个满足条件f 的怪兽为融合素材
等价于 aux.AddFusionProcMix(c,sub,insf,code1,table.unpack(fun)),fun 是包含 cc 个 满足条件 f 的卡的表

●void aux.AddFusionProcFun2(Card c, function f1, function f2, bool insf)
为c 添加融合召唤手续
用满足条件 f1 与 f2 的怪兽 各1只为融合素材
等价于 aux.AddFusionProcMix(c,false,insf,f1,f2)

●void aux.AddFusionProcFunRep(Card c, function f, int cc, bool insf)
为c 添加融合召唤手续
用 cc 个 满足相同条件 f 的怪兽为融合素材
等价于 aux.AddFusionProcMix(c,false,insf,table.unpack(fun)),fun 是包含 cc 个 满足条件 f 的卡的表

●void aux.AddFusionProcFunRep2(Card c, function f, int minc, int maxc, bool insf)
为c 添加融合召唤手续
用 minc-maxc 个 满足相同条件 f 的怪兽为融合素材
等价于 aux.AddFusionProcMixRep(c,false,insf,f,minc,maxc)

●void aux.AddFusionProcFunFun(Card c, function f1, function f2, int cc, bool sub, bool insf)
为c 添加融合召唤手续
用满足过滤条件 f1 的1只怪兽 ，和满足过滤条件 f2 的 cc 只怪兽为融合素材
等价于 aux.AddFusionProcMix(c,false,insf,f1,table.unpack(fun)),fun 是包含 cc 个 满足条件 f2 的卡的表

●void aux.AddFusionProcFunFunRep(Card c, function f1, function f2, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用满足过滤条件 f1 的1只怪兽 ，和满足过滤条件 f2 的 minc-maxc 只怪兽为融合素材
等价于 aux.AddFusionProcMixRep(c,false,insf,f2,minc,maxc,f1)

●void aux.AddFusionProcCodeFunRep(Card c, int code, function f, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为 code 的1只怪兽 ，和满足过滤条件 f 的 minc-maxc 只怪兽为融合素材
等价于 aux.AddFusionProcMixRep(c,sub,insf,f,minc,maxc,code1)

●void aux.AddFusionProcCode2FunRep(Card c, int code1, int code2, function f, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为 code1,code2 的各1只怪兽 ，和满足过滤条件 f 的 minc-maxc 只怪兽为融合素材
等价于 aux.AddFusionProcMixRep(c,sub,insf,f,minc,maxc,code1,code2)

●void aux.AddFusionProcShaddoll(Card c, int attribute)
影依融合怪兽专用，attribute 为需要的属性

●void aux.AddRitualProcGreater(Card c, function filter)
为c添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和可以超过仪式怪兽的原本等级

●void aux.AddRitualProcGreaterCode(Card c, int code)
为c添加仪式召唤效果
code 为仪式怪兽卡号，素材的仪式等级之和可以超过仪式怪兽的原本等级
等价于：aux.AddRitualProcGreater(c,aux.FilterBoolFunction(Card.IsCode,code)),并添加 fit_monster=code

●void aux.AddRitualProcEqual(Card c, function filter)
为c添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和必须等于仪式怪兽的原本等级

●void aux.AddRitualProcEqualCode(Card c, int code)
为c添加仪式召唤效果
code 为仪式怪兽卡号，素材的仪式等级之和必须等于仪式怪兽的原本等级
等价于：aux.AddRitualProcEqual(c,aux.FilterBoolFunction(Card.IsCode,code)) ,并添加 fit_monster=code

●void aux.AddRitualProcEqual2(Card c, function filter)
为c添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和必须等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)

●void aux.AddRitualProcEqual2Code(Card c, int code)
为c添加仪式召唤效果
code 为仪式怪兽卡号，素材的等级之和必须等于仪式怪兽的等级
等价于：aux.AddRitualProcEqual2(c,aux.FilterBoolFunction(Card.IsCode,code)) ,并添加 fit_monster=code

●void aux.AddRitualProcEqual2Code2(Card c, int code1, int code2)
为c添加仪式召唤效果
code1,code2 为仪式怪兽卡号，素材的等级之和必须等于仪式怪兽的等级
等价于：aux.AddRitualProcEqual2(c,aux.FilterBoolFunction(Card.IsCode,code1,code2)) ,并添加 fit_monster={code1,code2}

●void aux.EnablePendulumAttribute(Card c[, active_effect=true])
为灵摆怪兽c添加灵摆怪兽属性（灵摆召唤，灵摆卡的发动）
active_effect=false则不注册灵摆卡“卡的发动”的效果

●void aux.EnableReviveLimitPendulumSummonable(Card c[, int location=0xff])
如果 怪兽 c 从 location 灵摆召唤，也能解除苏生限制(?) (超天新龙 异色眼革命龙 (16306932))

●void aux.AddLinkProcedure(Card c, function f|nil, int minc[, int maxc=99, function gf|nil])
为c添加连接召唤手续
用 minc-maxc 个满足过滤条件 f [的卡片组里满足过滤条件 gf ]的怪兽作为连接素材

●void aux.GetLinkCount(Card c)
返回卡片 c 作为连接素材时当做的素材数量
function Auxiliary.GetLinkCount(c)
	if c:IsType(TYPE_LINK) and c:GetLink()>1 then
		return 1+0x10000*c:GetLink()
	else return 1 end
end

●bool aux.IsMaterialListCode(Card c, int code])
检测 c 是否是有卡名 code 为素材的卡
c.material

●bool aux.IsMaterialListSetCard(Card c, int setcode])
检测 c 是否是有字段 setcode 为素材的卡
c.material_setcode

●bool aux.IsCodeListed(Card c, int code])
检测 c 是否是有卡名 code 记述的卡
c.card_code_list

●int aux.GetColumn(Card c, int player=0)
返回以 player 来看的卡片 c 所在的那一列的序号，不包含 场地区域，从左到右 分别是 0~4

●int aux.MZoneSequence(int seq)
返回怪兽区的序号，从左到右 分别是 0~4 ,若在 额外怪兽区，则返回 左 1 或者 右 3 

●bool aux.disfilter1(Card c)
检测是否是 可以被无效效果的 怪兽
function Auxiliary.disfilter1(c)
	return c:IsFaceup() and not c:IsDisabled() and (not c:IsType(TYPE_NORMAL) or c:GetOriginalType()&TYPE_EFFECT~=0)
end

●bool aux.bdcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING 的 condition
function Auxiliary.bdcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:IsRelateToBattle()
end

●bool aux.bdocon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且是与对方怪兽战斗 的 condition
function Auxiliary.bdocon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:IsRelateToBattle() and c:IsStatus(STATUS_OPPO_BATTLE)
end

●bool aux.bdgcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且战斗破坏对方怪兽送去墓地 的 condition
function Auxiliary.bdgcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local bc=c:GetBattleTarget()
	return c:IsRelateToBattle() and bc:IsLocation(LOCATION_GRAVE) and bc:IsType(TYPE_MONSTER)
end

●bool aux.bdogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且是与对方怪兽战斗并战斗破坏对方怪兽送去墓地 的 condition
function Auxiliary.bdogcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local bc=c:GetBattleTarget()
	return c:IsRelateToBattle() and c:IsStatus(STATUS_OPPO_BATTLE) and bc:IsLocation(LOCATION_GRAVE) and bc:IsType(TYPE_MONSTER)
end

●bool aux.dogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否是从自己场上被对方破坏送去墓地 SetCondition
function Auxiliary.dogcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:GetPreviousControler()==tp and c:IsReason(REASON_DESTROY) and rp==1-tp
end

●bool aux.exccon(Effect e)
这张卡送去墓地的回合 不能发动这个效果 的简单写法 SetCondition
function aux.exccon(e)
	return Duel.GetTurnCount()~=e:GetHandler():GetTurnID() or e:GetHandler():IsReason(REASON_RETURN)
end

●bool aux.chainreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
死亡魔导龙(81059524)用了此函数，其实就是相当于
function aux.chainreg(e,tp,eg,ep,ev,re,r,rp)
	if e:GetHandler():GetFlagEffect(1)==0 then
		e:GetHandler():RegisterFlagEffect(1,RESET_EVENT+RESETS_STANDARD-RESET_TURN_SET+RESET_CHAIN,0,1)
	end
end

●bool aux.imval1(Effect e, Card c)
不会成为攻击对象的过滤函数的简单写法，用在效果注册里 SetValue
function aux.imval1(e,c)
	return not c:IsImmuneToEffect(e)
end

●bool aux.indsval(Effect e, Effect re, int rp)
不会被自己的卡的效果破坏的过滤函数的简单写法，用在效果注册里 SetValue
function aux.indsval(e,re,rp)
	return rp==e:GetHandlerPlayer()
end

●bool aux.indoval(Effect e, Effect re, int rp)
不会被对方的卡的效果破坏的过滤函数的简单写法，用在效果注册里 SetValue
function aux.indoval(e,re,rp)
	return rp==1-e:GetHandlerPlayer()
end

●bool aux.tgsval(Effect e, Effect re, int rp)
不会成为自己的卡的效果对象的过滤函数的简单写法，用在效果注册里 SetValue
function aux.tgsval(e,re,rp)
	return rp==e:GetHandlerPlayer()
end

●bool aux.tgoval(Effect e, Effect re, int rp)
不会成为对方的卡的效果对象的过滤函数的简单写法，用在效果注册里 SetValue
function aux.tgoval(e,re,rp)
	return rp==e:GetHandlerPlayer()
end

●bool aux.nzatk(Card c)
攻击力不为0的表侧表示的怪兽的过滤函数的简单写法
function aux.nzatk(c)
	return c:IsFaceup() and c:GetAttack()>0
end

●bool aux.nzdef(Card c)
守备力不为0的表侧表示的怪兽的过滤函数的简单写法
function aux.nzdef(c)
	return c:IsFaceup() and c:GetDefense()>0
end

●bool aux.sumreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
妖仙兽 阎魔巳裂(39853199)和一些其他卡(49249907,93368494)用了此函数，不过此函数★意★义★不★明★。
54109233 虽然没用此函数，但是用了一样的写法，同样是★意★义★不★明★，其实就是相当于
function aux.sumreg(e,tp,eg,ep,ev,re,r,rp)
	local tc=eg:GetFirst()
	local code=e:GetLabel()
	while tc do
		if tc:GetOriginalCode()==code then
			tc:RegisterFlagEffect(code,RESET_EVENT+0x1ec0000+RESET_PHASE+PHASE_END,0,1)
		end
		tc=eg:GetNext()
	end
end

●bool aux.fuslimit(Effect e, Effect se, int sp, int st)
不能用 融合召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.fuslimit(e,se,sp,st)
	return st&SUMMON_TYPE_FUSION==SUMMON_TYPE_FUSION
end

●bool aux.ritlimit(Effect e, Effect se, int sp, int st)
不能用 仪式召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.ritlimit(e,se,sp,st)
	return st&SUMMON_TYPE_RITUAL==SUMMON_TYPE_RITUAL
end

●bool aux.synlimit(Effect e, Effect se, int sp, int st)
不能用 同调召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.synlimit(e,se,sp,st)
	return st&SUMMON_TYPE_SYNCHRO==SUMMON_TYPE_SYNCHRO
end

●bool aux.xyzlimit(Effect e, Effect se, int sp, int st)
不能用 超量召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.xyzlimit(e,se,sp,st)
	return st&SUMMON_TYPE_XYZ==SUMMON_TYPE_XYZ
end

●bool aux.penlimit(Effect e, Effect se, int sp, int st)
不能用 灵摆召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.penlimit(e,se,sp,st)
	return st&SUMMON_TYPE_PENDULUM==SUMMON_TYPE_PENDULUM
end

●bool aux.linklimit(Effect e, Effect se, int sp, int st)
不能用 连接召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.linklimit(e,se,sp,st)
	return st&SUMMON_TYPE_LINK==SUMMON_TYPE_LINK
end

●bool aux.damcon1(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
玩家 tp 受到伤害 这个条件的简单写法，，用在效果注册里 SetCondition
function aux.damcon1(e,tp,eg,ep,ev,re,r,rp)
	local e1=Duel.IsPlayerAffectedByEffect(tp,EFFECT_REVERSE_DAMAGE)
	local e2=Duel.IsPlayerAffectedByEffect(tp,EFFECT_REVERSE_RECOVER)
	local rd=e1 and not e2
	local rr=not e1 and e2
	local ex,cg,ct,cp,cv=Duel.GetOperationInfo(ev,CATEGORY_DAMAGE)
	if ex and (cp==tp or cp==PLAYER_ALL) and not rd and not Duel.IsPlayerAffectedByEffect(tp,EFFECT_NO_EFFECT_DAMAGE) then
		return true
	end
	ex,cg,ct,cp,cv=Duel.GetOperationInfo(ev,CATEGORY_RECOVER)
	return ex and (cp==tp or cp==PLAYER_ALL) and rr and not Duel.IsPlayerAffectedByEffect(tp,EFFECT_NO_EFFECT_DAMAGE)
end

●bool aux.qlifilter(Effect e, Effect te)
机壳怪兽通用抗性(不受原本等级·阶级比这张卡等级低的怪兽效果影响)的过滤函数的简单写法，用在效果注册里 SetValue
te 是 将要影响到 e:GetHandler() 的效果
function aux.qlifilter(e,te)
	if te:IsActiveType(TYPE_MONSTER) and te:IsActivated() then
		local lv=e:GetHandler():GetLevel()
		local ec=te:GetOwner()
		if ec:IsType(TYPE_LINK) then
			return false
		elseif ec:IsType(TYPE_XYZ) then
			return ec:GetOriginalRank()<lv
		else
			return ec:GetOriginalLevel()<lv
		end
	else
		return false
	end
end

●bool aux.gbspcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
剑斗兽通用效果(用「剑斗兽」怪兽的效果特殊召唤)的过滤条件的简单写法，用在效果注册里 SetCondition
2619149,4253484,31247589,42592719,65984457,78868776,  虽然写法不同，但是没问题
function aux.gbspcon(e,tp,eg,ep,ev,re,r,rp)
	local st=e:GetHandler():GetSummonType()
	return st>=(SUMMON_TYPE_SPECIAL+100) and st<(SUMMON_TYPE_SPECIAL+150)
end

●bool aux.evospcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
进化龙通用效果(用「进化虫」怪兽的效果特殊召唤)的过滤条件的简单写法，用在效果注册里 SetCondition
function aux.evospcon(e,tp,eg,ep,ev,re,r,rp)
	local st=e:GetHandler():GetSummonType()
	return st>=(SUMMON_TYPE_SPECIAL+150) and st<(SUMMON_TYPE_SPECIAL+180)
end

●function aux.NecroValleyFilter(function f)
根据过滤条件f返回一个新的过滤条件：满足f并且不受王家长眠之谷的影响的卡
function Auxiliary.NecroValleyFilter(f)
	return	function(target,...)
				return f(target,...) and not (target:IsHasEffect(EFFECT_NECRO_VALLEY) and Duel.IsChainDisablable(0))
			end
end

●bool aux.bfgcost(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp, int chk)
把这张卡除外 的过滤条件的简单写法，，用在效果注册的 cost 里
function aux.bfgcost(e,tp,eg,ep,ev,re,r,rp,chk)
	if chk==0 then return e:GetHandler():IsAbleToRemoveAsCost() end
	Duel.Remove(e:GetHandler(),POS_FACEUP,REASON_COST)
end

●bool aux.ExceptThisCard(Effect e)
若 e:GetHandler() 与效果 e 有联系，则返回 e:GetHandler() ,否则返回 nil
function aux.ExceptThisCard(e)
	local c=e:GetHandler()
	if c:IsRelateToEffect(e) then return c else return nil end
end

========== Debug ==========
●void Debug.Message(any msg)
显示消息

●Card Debug.AddCard(int code, int owner, int player, int location, int seq, int pos[, bool proc=false])
添加卡片，将卡号为code的卡片的持有者设置为owner，以表示形式pos放置在player的场上位于location上序号为seq的格子处
proc=true则完成正规召唤程序(即解除苏生限制)

●void Debug.SetPlayerInfo(int playerid, int lp, int startcount, int drawcount)
设置玩家信息，基本分为lp，初始手卡为startcount张，每回合抽drawcount张
在残局当中， playerid ：自己=0,对方=1

●void Debug.PreSummon(Card c, int sum_type[, int sum_location=0])
设置卡片c的召唤信息：以 sum_type 方法(通常召唤、特殊召唤等)[从 sum_location]出场

●bool Debug.PreEquip(Card equip_card, Card target)
为target添加装备equip_card ，返回值表示是否成功

●void Debug.PreSetTarget(Card c, Card target)
把target选为c的永续对象

●void Debug.PreAddCounter(Card c, int counter_type[, int count=0])
为c添加count个counter_type的指示物

●void Debug.ReloadFieldBegin(int flag[, int rule=3])
以选项flag开始布局
	flag 残局： DUEL_ATTACK_FIRST_TURN+DUEL_SIMPLE_AI
		 大师1规则： DUEL_OBSOLETE_RULING
	rule=4 是新大师规则
	
●void Debug.ReloadFieldEnd()
布局结束

●void Debug.SetAIName(string name)
设置AI的名字，最大长度 100 个字符（1个汉字2个字符）

●void Debug.ShowHint(string msg)
显示消息提示框，最大长度 1024 个字符（1个汉字2个字符）
